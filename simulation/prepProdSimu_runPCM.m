function prepProdSimu_runPCM(vtemp,vord,vinter,vnoise,n)

% prepProdSimu_runPCM(filename)
%
% compares models generated from simulated data to new simulated data
%
% inputs:
% filename = name of simulated data file to test models against
%            generated by prepProdSimu_runsimu
%
% models defined by prepProdSimu_runsimu, make sure you generate these first.
% specification for models is found below
% RY 10/2022

% addpath(genpath('Z:\rhys\prepProd2\matlab')); %Adjust! loaded with subdirectories (genpath command)
% addpath(genpath('Z:\toolboxes\tools')); %joern's extensions for spm
% addpath(genpath('Z:\toolboxes\userfun')); %joern's util tools (open source)
% addpath(genpath('Z:\toolboxes\rsatoolbox_matlab')); %RSA toolbox
% addpath(genpath('Z:\toolboxes\pcm_toolbox')); %PCM toolbox

simuDir = 'Z:\rhys\prepProd2\data\imaging\simulations';

sn = 24; %number of subjects

D=[];
for i=1:sn %for subject n
    for j=1:n %for iterations
        Y=prepProdSimu_makedata('vtemp',vtemp,'vord',vord,'vinter',vinter,'vnoise',vnoise);
        
        D.data(:,:,j) = Y;
        clear('Y')
    end%for iterations
    
    A.data{i} = mean(D.data,3);
    
end%for subject n

%load 3 representative models
load([simuDir '\' 'simulation_temp_1_ord_0_int_0_noise_0_n_1000' '.mat'])
timingModel = D;

load([simuDir '\' 'simulation_temp_0_ord_1_int_0_noise_0_n_1000' '.mat'])
orderModel = D;

load([simuDir '\' 'simulation_temp_0_ord_0_int_1_noise_0_n_1000' '.mat'])
integratedModel = D;

clear('D')

partVec = repmat(1:6,4,1); %labelling runs 1:6 (imaging runs)
partVec = reshape(partVec,1,[])';

condVec = repmat([1;2;3;4], 6,1); %labelling conditions 1:4 (sequences)

for s=1:length(A.data)
    G_hat(:,:,s)=pcm_estGCrossval(A.data{s},partVec,condVec);
end;
Gm = mean(G_hat,3); % Mean estimate

timingModel.G = pcm_estGCrossval(timingModel.data,partVec,condVec);
orderModel.G = pcm_estGCrossval(orderModel.data,partVec,condVec);
integratedModel.G = pcm_estGCrossval(integratedModel.data,partVec,condVec);

figure
subplot(2,4,1);
H = eye(4)-ones(4)/4;
imagesc(H*Gm*H');
title('Empirical Data')

C= pcm_indicatorMatrix('allpairs',[1:4]');
[COORD,l]=pcm_classicalMDS(Gm,'contrast',C);
subplot(2,4,2);
plot(COORD(:,1),COORD(:,2),'o');
axis equal;

% visualise models
subplot(2,4,5);
imagesc(orderModel.G);
title('Order control')

subplot(2,4,6);
imagesc(timingModel.G);
title('Timing control')

subplot(2,4,7);
imagesc(integratedModel.G);
title('Integrated control')

% ----------------------------------------------------------------
% Now build the models
% Model 1: Null model for baseline: here we use a model which has all finger
% Patterns be independent - i.e. all finger pairs are equally far away from
% each other
% M{1}.type       = 'component';
% M{1}.numGparams = 1;
% M{1}.Gc         = ones(4);
% M{1}.name       = 'null';

% Model 2: Order model, derived from simulations with
% high order decoding
M{1}.type       = 'component';
M{1}.numGparams = 1;
M{1}.Gc         = orderModel.G;
M{1}.name       = 'O';

% Model 3: Timing model, derived from simulations with
% high timing decoding
M{2}.type       = 'component';
M{2}.numGparams = 1;
M{2}.Gc         = timingModel.G;
M{2}.name       = 'T';

% Model 4: Integrated model, derived from simulations with
% high integrated decoding
M{3}.type       = 'component';
M{3}.numGparams = 1;
M{3}.Gc         = integratedModel.G;
M{3}.name       = 'I';

M = pcm_constructModelFamily(M);

% % Model 5: Additive mixture between order and timing models
% M{5}.type       = 'component';
% M{5}.numGparams = 2;
% M{5}.Gc(:,:,1)  = orderModel.G;
% M{5}.Gc(:,:,2)  = timingModel.G;
% M{5}.name       = 'order + timing';

% Model 6: Free model as Noise ceiling
% M{6}.type       = 'freechol';
M{end+1}.type       = 'freedirect';
M{end}.numCond    = 4;
M{end}.name       = 'noiseceiling';
M{end}            = pcm_prepFreeModel(M{end});

% Treat the run effect as random or fixed?
% We are using a fixed run effect here, as we are not interested in the
% activity relative the the baseline (rest) - so as in RSA, we simply
% subtract out the mean patttern across all conditions.
runEffect  = 'fixed';

Y = A.data; % function requires cell input
% partVec = num2cell(partVec,1);
% condVec = num2cell(condVec,1);

% Fit the models on the group level
[Tgroup,theta] = pcm_fitModelGroup(Y,M,partVec,condVec,'runEffect',runEffect,'fitScale',1);

% Fit the models through cross-subject crossvalidation
[Tcross,thetaCr] = pcm_fitModelGroupCrossval(Y,M,partVec,condVec,'runEffect',runEffect,'groupFit',theta,'fitScale',1);

% Provide a plot of the crossvalidated likelihoods
subplot(2,4,[4 8]);
T = pcm_plotModelLikelihood_RY(Tcross,M,'upperceil',Tgroup.likelihood(:,length(M)));

varargout={T,M};
