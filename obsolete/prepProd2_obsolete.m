function prepProd2_obsolete(ana)

corticalPCMDir=[baseDir filesep 'imaging' filesep 'cortical' filesep 'pcm'];

%CERES cerebellum variables

allcbRegions = ... %cerebellar ROIs defined from cerebellar aseg, generated by https://www.volbrain.upv.es/
    {'left_lobule_1-2', 'left_lobule_3', 'left_lobule_4', 'left_lobule_5', 'left_lobule_6', 'left_lobule_crus_1',...
    'left_lobule_crus_2', 'left_lobule_7b', 'left_lobule_8a', 'left_lobule_8b', 'left_lobule_9', 'left_lobule_10', 'left_white_matter',...
    'right_lobule_1-2', 'right_lobule_3', 'right_lobule_4', 'right_lobule_5', 'right_lobule_6', 'right_lobule_crus_1',...
    'right_lobule_crus_2', 'right_lobule_7b', 'right_lobule_8a', 'right_lobule_8b','right_lobule_9', 'right_lobule_10', 'right_white_matter'};

cbRegions = ... %cerebellar ROIs used in prepProd
    {'left_lobule_5', 'left_lobule_6', 'left_lobule_crus_1','left_lobule_crus_2','right_lobule_5', 'right_lobule_6', 'right_lobule_crus_1', 'right_lobule_crus_2'};

switch(ana)
    
    case 'suit_segment' %%%%%%%%%%%%%%%%%%% BEGINNING OF SUIT DECODING ANALYSIS (CEREBELLUM) %%%%%%%%%%%%%%%%%%%%%%%
        %Isolate the cerebellum of each participant - produces 'c_<source>_pcereb' (cerebellar mask) and '<source>_seg1/2' (grey and white matter respectively) images
        
        sn=varargin{1};
        cd([baseDir '/imaging/anatomicals/' subj_name{sn}]);
        disp(['suit_segmenting ' subj_name{sn}])
        
        anatomical = {[subj_name{sn} '_anatomical.nii']};
        
        suit_isolate_seg(anatomical, 'maskp', 0.2) %change maskp for probability value. Higher = tighter mask. Hand-correct using MRIcron if necessary
    case 'suit_make_mask' %restrict area of analysis to grey matter - produces 'maskbrainSUIT.nii'
        
        s=varargin{1};
        
        if isfolder([baseDir '/imaging/suit/' subj_name{s}]) == 0
            mkdir([baseDir '/imaging/suit/' subj_name{s}])
        end
        
        mask=fullfile(glmDir, subj_name{s},'mask.nii');
        %         suit=fullfile(anatDir, subj_name{s},['c_', subj_name{s},'_anatomical_pcereb.nii']); %pcereb holds all cerebellum-related regions to a value of 1...
        suit=fullfile(anatDir, subj_name{s},[subj_name{s}, '_anatomical_seg1.nii']); %whereas _seg1 is only grey matter and sets extra-cerebellar regions (e.g. pons) to values other than 1...
        omask=fullfile(suitDir, subj_name{s},'maskbrainSUIT.nii');
        
        spm_imcalc_ui({mask,suit},omask,'i1>0 & i2>0.999',{}); %so including a mask of 0.999 makes sure we only include cerebellar regions.
    case 'MVA_searchSUIT' % Define the search lights for the MVA analysis
        
        s=varargin{1};
        
        radius=16;
        numVox=160;
        
        cd(fullfile(suitDir, subj_name{s}));
        V=spm_vol('maskbrainSUIT.nii'); %preceded by case suit_make_mask
        X=spm_read_vols(V);
        [i,j,k]=ind2sub(size(X),find(X~=0));
        vox=[i j k];
        
        [LI,voxmin,voxmax,n]=lmva_voxelselection(vox(:,:)',vox',[radius numVox],V.mat,V.dim,[],'mva160_numvoxSUIT.nii');
        save volsearch160SUIT.mat vox LI voxmin voxmax n
    case 'MVA_do_overallMov_suit'
        
        s=varargin{1};
        
        cd(fullfile(glmDir, subj_name{s}));
        load SPM;
        nrruns=length(SPM.nscan);
        
        
        runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
        prod      =[1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0];
        prod=[repmat(prod,1,nrruns) runBSL];
        
        c=repmat(1:4,1,nrruns); % extract conditions (leave out errors!)
        run=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
        out = {fullfile(suitDir, subj_name{s}, [subj_name{s}, '_accuracy_Comb_160_MovSUIT.nii'])};
        
        
        % Generate column indices for Cross-validation, where
        % cell i contains column indices of the respective test and
        % train set
        for i=1:nrruns
            test{i}=find(run==i);  %fprintf('test:'); display(test{i}');
            train{i}=find(run~=i);  %fprintf('train:'); display(train{i}');
        end;
        
        [row,col] = find(prod>0);
        P={SPM.Vbeta(1:126).fname}';
        Pselect=[];
        for i=1:length(col)
            Pselect{i,1}= P{col(i)};
        end;
        
        tstart = tic
        lmva_spm(fullfile(suitDir,subj_name{s},'volsearch160SUIT.mat'),Pselect,out,@combinedclass,'params',{c,run,train,test});
        telapsed = toc(tstart)
    case 'MVA_do_overallPrep_suit'                 % Conduct the classification analysis 4 sequences
        s=varargin{1};
        
        cd(fullfile(glmDir, subj_name{s}));
        load SPM;
        nrruns=length(SPM.nscan);
        
        
        runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
        prep      =[0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0];
        prep=[repmat(prep,1,nrruns) runBSL];
        
        c=repmat(1:4,1,nrruns); % extract conditions (leave out errors!)
        run=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
        out = {fullfile(suitDir, subj_name{s}, [subj_name{s}, '_accuracy_Comb_160_Prep.nii'])};
        
        
        % Generate column indices for Cross-validation, where
        % cell i contains column indices of the respective test and
        % train set
        for i=1:nrruns
            test{i}=find(run==i);  %fprintf('test:'); display(test{i}');
            train{i}=find(run~=i);  %fprintf('train:'); display(train{i}');
        end;
        
        [row,col] = find(prep>0);
        P={SPM.Vbeta(1:126).fname}';
        Pselect=[];
        for i=1:length(col)
            Pselect{i,1}= P{col(i)};
        end;
        
        tstart = tic
        lmva_spm(fullfile(suitDir,subj_name{s},'volsearch160SUIT.mat'),Pselect,out,@combinedclass,'params',{c,run,train,test});
        telapsed = toc(tstart)
    case 'MVA_do_spatOneout_Mov_suit'
        sn=varargin{1};
        
        for s=sn
            
            s=varargin{1};
            
            cd(fullfile(glmDir, subj_name{s}));
            load SPM;
            nrruns=length(SPM.nscan);
            
            
            runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
            prod      =[1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0];
            prod=[repmat(prod,1,nrruns) runBSL];
            
            c=repmat([1 1 2 2],1,nrruns); % extract conditions (leave out errors!)
            run=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
            out = {fullfile(suitDir, subj_name{s}, [subj_name{s}, '_accuracy_Spat_160_Mov.nii'])};
            
            
            % Generate column indices for cross-validation, where
            % cell i contains column indices of the respective test and
            % train set
            %%%
            oneout=[1 0; 0 1];
            oneout=repmat(oneout,1,12);
            j=0;
            for i=1:2:nrruns*2
                j=j+1;
                test{i}   =find(run==j & oneout(1,:)==1); % Classify S1 vs S2 with T1
                test{i+1} =find(run==j & oneout(2,:)==1); % Classify S1 vs S2 with T2
                
                
                train{i}  =find(run~=j & oneout(1,:)~=1); % Train on S1 vs S2 with T2 ....
                train{i+1}=find(run~=j & oneout(2,:)~=1); % Train on S1 vs S2 with T1 in different runs from testing
                
            end;
            
            [row,col] = find(prod>0);
            P={SPM.Vbeta(1:126).fname}';
            Pselect=[];
            for i=1:length(col)
                Pselect{i,1}= P{col(i)};
            end;
            
            tstart = tic
            lmva_spm(fullfile(suitDir,subj_name{s},'volsearch160SUIT.mat'),Pselect,out,@combinedclass,'params',{c,run,train,test});
            telapsed = toc(tstart);
            
        end;
    case 'MVA_do_spatOneout_Prep_suit'
        sn=varargin{1};
        
        for s=sn
            
            s=varargin{1};
            
            cd(fullfile(glmDir, subj_name{s}));
            load SPM;
            nrruns=length(SPM.nscan);
            
            
            runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
            prep      =[0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0];
            prep=[repmat(prep,1,nrruns) runBSL];
            
            c=repmat([1 1 2 2],1,nrruns); % extract conditions (leave out errors!)
            run=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
            out = {fullfile(suitDir, subj_name{s}, [subj_name{s}, '_accuracy_Spat_160_Prep.nii'])};
            
            
            % Generate column indices for cross-validation, where
            % cell i contains column indices of the respective test and
            % train set
            %%%
            oneout=[1 0; 0 1];
            oneout=repmat(oneout,1,12);
            j=0;
            for i=1:2:nrruns*2
                j=j+1;
                test{i}   =find(run==j & oneout(1,:)==1); % Classify S1 vs S2 with T1
                test{i+1} =find(run==j & oneout(2,:)==1); % Classify S1 vs S2 with T2
                
                
                train{i}  =find(run~=j & oneout(1,:)~=1); % Train on S1 vs S2 with T2 ....
                train{i+1}=find(run~=j & oneout(2,:)~=1); % Train on S1 vs S2 with T1 in different runs from testing
                
            end;
            
            [row,col] = find(prep>0);
            P={SPM.Vbeta(1:126).fname}';
            Pselect=[];
            for i=1:length(col)
                Pselect{i,1}= P{col(i)};
            end;
            
            tstart = tic
            lmva_spm(fullfile(suitDir,subj_name{s},'volsearch160SUIT.mat'),Pselect,out,@combinedclass,'params',{c,run,train,test});
            telapsed = toc(tstart);
            
        end;
    case 'MVA_do_tempOneout_Mov_suit'
        sn=varargin{1};
        
        for s=sn
            
            s=varargin{1};
            
            cd(fullfile(glmDir, subj_name{s}));
            load SPM;
            nrruns=length(SPM.nscan);
            
            
            runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
            prod      =[1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0];
            prod=[repmat(prod,1,nrruns) runBSL];
            
            c=repmat([1 2 1 2],1,nrruns); % extract conditions (leave out errors!)
            run=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
            out = {fullfile(suitDir, subj_name{s}, [subj_name{s}, '_accuracy_Temp_160_Mov.nii'])};
            
            
            % Generate column indices for cross-validation, where
            % cell i contains column indices of the respective test and
            % train set
            %%%
            oneout=[1 1 0 0; 0 0 1 1];
            oneout=repmat(oneout,1,6);
            j=0;
            for i=1:2:nrruns*2
                j=j+1;
                test{i}   =find(run==j & oneout(1,:)==1); % Classify S1 vs S2 with T1
                test{i+1} =find(run==j & oneout(2,:)==1); % Classify S1 vs S2 with T2
                
                
                train{i}  =find(run~=j & oneout(1,:)~=1); % Train on S1 vs S2 with T2 ....
                train{i+1}=find(run~=j & oneout(2,:)~=1); % Train on S1 vs S2 with T1 in different runs from testing
                
            end;
            
            [row,col] = find(prod>0);
            P={SPM.Vbeta(1:126).fname}';
            Pselect=[];
            for i=1:length(col)
                Pselect{i,1}= P{col(i)};
            end;
            
            tstart = tic
            lmva_spm(fullfile(suitDir,subj_name{s},'volsearch160SUIT.mat'),Pselect,out,@combinedclass,'params',{c,run,train,test});
            telapsed = toc(tstart);
            
        end;
    case 'MVA_do_tempOneout_Prep_suit'
        sn=varargin{1};
        
        for s=sn
            
            s=varargin{1};
            
            cd(fullfile(glmDir, subj_name{s}));
            load SPM;
            nrruns=length(SPM.nscan);
            
            
            runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
            prep      =[0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0];
            prep=[repmat(prep,1,nrruns) runBSL];
            
            c=repmat([1 2 1 2],1,nrruns); % extract conditions (leave out errors!)
            run=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
            out = {fullfile(suitDir, subj_name{s}, [subj_name{s}, '_accuracy_Temp_160_Prep.nii'])};
            
            
            % Generate column indices for cross-validation, where
            % cell i contains column indices of the respective test and
            % train set
            %%%
            oneout=[1 1 0 0; 0 0 1 1];
            oneout=repmat(oneout,1,6);
            j=0;
            for i=1:2:nrruns*2
                j=j+1;
                test{i}   =find(run==j & oneout(1,:)==1); % Classify S1 vs S2 with T1
                test{i+1} =find(run==j & oneout(2,:)==1); % Classify S1 vs S2 with T2
                
                
                train{i}  =find(run~=j & oneout(1,:)~=1); % Train on S1 vs S2 with T2 ....
                train{i+1}=find(run~=j & oneout(2,:)~=1); % Train on S1 vs S2 with T1 in different runs from testing
                
            end;
            
            [row,col] = find(prep>0);
            P={SPM.Vbeta(1:126).fname}';
            Pselect=[];
            for i=1:length(col)
                Pselect{i,1}= P{col(i)};
            end;
            
            tstart = tic
            lmva_spm(fullfile(suitDir,subj_name{s},'volsearch160SUIT.mat'),Pselect,out,@combinedclass,'params',{c,run,train,test});
            telapsed = toc(tstart);
            
        end;
    case 'MVA_do_Int_Mov_suit'    %'integrated' (subtracts out main effects, i.e. common patterns for T1, T2, S1, S2 and classifies residual)
        s=varargin{1};
        
        cd(fullfile(glmDir, subj_name{s}));
        load SPM;
        nrruns=length(SPM.nscan);
        
        
        runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
        prod      =[1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0];
        prod=[repmat(prod,1,nrruns) runBSL];
        
        c=repmat(1:4,1,nrruns); % extract conditions (leave out errors!)
        run=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
        out = {fullfile(suitDir, subj_name{s}, [subj_name{s}, '_accuracy_Int_160_Mov.nii'])};
        
        
        % Generate column indices for Cross-validation, where
        % cell i contains column indices of the respective test and
        % train set
        for i=1:nrruns
            test{i}=find(run==i);  %fprintf('test:'); display(test{i}');
            train{i}=find(run~=i);  %fprintf('train:'); display(train{i}');
        end;
        
        [row,col] = find(prod>0);
        P={SPM.Vbeta(1:126).fname}';
        Pselect=[];
        for i=1:length(col)
            Pselect{i,1}= P{col(i)};
        end;
        
        tstart = tic
        lmva_spm(fullfile(suitDir,subj_name{s},'volsearch160SUIT.mat'),Pselect,out,@prepProd2_combinedclass_corrected4Main,'params',{c,run,train,test});
        telapsed = toc(tstart)
    case 'MVA_do_Int_Prep_suit'    %'integrated' (subtracts out main effects, i.e. common patterns for T1, T2, S1, S2 and classifies residual)
        s=varargin{1};
        
        cd(fullfile(glmDir, subj_name{s}));
        load SPM;
        nrruns=length(SPM.nscan);
        
        
        runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
        prep      =[0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0];
        prep=[repmat(prep,1,nrruns) runBSL];
        
        c=repmat(1:4,1,nrruns); % extract conditions (leave out errors!)
        run=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
        out = {fullfile(suitDir, subj_name{s}, [subj_name{s}, '_accuracy_Int_160_Prep.nii'])};
        
        
        % Generate column indices for Cross-validation, where
        % cell i contains column indices of the respective test and
        % train set
        for i=1:nrruns
            test{i}=find(run==i);  %fprintf('test:'); display(test{i}');
            train{i}=find(run~=i);  %fprintf('train:'); display(train{i}');
        end;
        
        [row,col] = find(prep>0);
        P={SPM.Vbeta(1:126).fname}';
        Pselect=[];
        for i=1:length(col)
            Pselect{i,1}= P{col(i)};
        end;
        
        tstart = tic
        lmva_spm(fullfile(suitDir,subj_name{s},'volsearch160SUIT.mat'),Pselect,out,@prepProd2_combinedclass_corrected4Main,'params',{c,run,train,test});
        telapsed = toc(tstart)
    case 'MVA_zValue_suit'
        
        s=varargin{1};
        cd(fullfile(suitDir,subj_name{s}));
        
        numTests=6;
        numCat=4;
        mu=1/numCat; %mu=0.25;
        N=numTests*numCat;
        sigma=sqrt(mu*(1-mu)*1/N);
        
        images= {'_accuracy_Comb_160_Mov','_accuracy_Comb_160_Prep','_accuracy_Int_160_Mov','_accuracy_Int_160_Prep'};
        %         images= {'_accuracy_Comb_160_Mov','_accuracy_Comb_160_Prep'};
        
        outimages={'_zacc_Comb_160_Mov','_zacc_Comb_160_Prep','_zacc_Int_160_Mov','_zacc_Int_160_Prep'};
        %         outimages={'_zacc_Comb_160_Mov','_zacc_Comb_160_Prep'};
        
        
        for j=1:numel(images)
            input_image= fullfile(suitDir,subj_name{s},[subj_name{s} images{j} '.nii']);
            output_image= fullfile(suitDir,subj_name{s},[subj_name{s} outimages{j} '.nii']);
            spmj_imcalc_mtx(input_image, output_image,...
                sprintf('(X./X).*((X-%d)/%d)',mu, sigma)); %(X./X) acts like a mask! z_accuracy=(accuracy-mu)/sigma;
        end;
    case 'MVA_zValue_oneOut_suit'
        
        s=varargin{1};
        cd(fullfile(suitDir,subj_name{s}));
        
        takeOneOutIter=2;
        numTests=6;
        numCat=2;
        mu=1/numCat; %mu=0.5;
        N=numTests*numCat*takeOneOutIter;
        sigma=sqrt(mu*(1-mu)*1/N);
        
        images= {'_accuracy_Spat_160_Mov','_accuracy_Spat_160_Prep','_accuracy_Temp_160_Mov','_accuracy_Temp_160_Prep'};
        
        outimages={'_zacc_Spat_160_Mov','_zacc_Spat_160_Prep','_zacc_Temp_160_Mov','_zacc_Temp_160_Prep'};
        
        
        for j=1:numel(images)
            input_image= fullfile(suitDir,subj_name{s},[subj_name{s} images{j} '.nii']);
            output_image= fullfile(suitDir,subj_name{s},[subj_name{s} outimages{j} '.nii']);
            spmj_imcalc_mtx(input_image, output_image,...
                sprintf('(X./X).*((X-%d)/%d)',mu, sigma)); %(X./X) acts like a mask! z_accuracy=(accuracy-mu)/sigma;
        end;
    case 'MVA_smooth_suit'
        
        s=varargin{1};
        
        s=varargin{1};
        comb=fullfile(suitDir, subj_name{s},[subj_name{s} '_zacc_Comb_160_Mov.nii']); %%MVPA smoother
        scomb=fullfile(suitDir, subj_name{s},[subj_name{s} '_szacc_Comb_160_Mov.nii']);
        spm_smooth(comb,scomb,[4 4 4]); %smooth with 4mm kernel
        
        comb=fullfile(suitDir, subj_name{s},[subj_name{s} '_zacc_Comb_160_Prep.nii']); %%MVPA smoother
        scomb=fullfile(suitDir, subj_name{s},[subj_name{s} '_szacc_Comb_160_Prep.nii']);
        spm_smooth(comb,scomb,[4 4 4]); %smooth with 4mm kernel
        
        comb=fullfile(suitDir, subj_name{s},[subj_name{s} '_zacc_Spat_160_Mov.nii']); %%MVPA smoother
        scomb=fullfile(suitDir, subj_name{s},[subj_name{s} '_szacc_Spat_160_Mov.nii']);
        spm_smooth(comb,scomb,[4 4 4]); %smooth with 4mm kernel
        
        comb=fullfile(suitDir, subj_name{s},[subj_name{s} '_zacc_Spat_160_Prep.nii']); %%MVPA smoother
        scomb=fullfile(suitDir, subj_name{s},[subj_name{s} '_szacc_Spat_160_Prep.nii']);
        spm_smooth(comb,scomb,[4 4 4]); %smooth with 4mm kernel
        
        comb=fullfile(suitDir, subj_name{s},[subj_name{s} '_zacc_Temp_160_Mov.nii']); %%MVPA smoother
        scomb=fullfile(suitDir, subj_name{s},[subj_name{s} '_szacc_Temp_160_Mov.nii']);
        spm_smooth(comb,scomb,[4 4 4]); %smooth with 4mm kernel
        
        comb=fullfile(suitDir, subj_name{s},[subj_name{s} '_zacc_Temp_160_Prep.nii']); %%MVPA smoother
        scomb=fullfile(suitDir, subj_name{s},[subj_name{s} '_szacc_Temp_160_Prep.nii']);
        spm_smooth(comb,scomb,[4 4 4]); %smooth with 4mm kernel
        
        comb=fullfile(suitDir, subj_name{s},[subj_name{s} '_zacc_Int_160_Mov.nii']); %%MVPA smoother
        scomb=fullfile(suitDir, subj_name{s},[subj_name{s} '_szacc_Int_160_Mov.nii']);
        spm_smooth(comb,scomb,[4 4 4]); %smooth with 4mm kernel
        
        comb=fullfile(suitDir, subj_name{s},[subj_name{s} '_zacc_Int_160_Prep.nii']); %%MVPA smoother
        scomb=fullfile(suitDir, subj_name{s},[subj_name{s} '_szacc_Int_160_Prep.nii']);
        spm_smooth(comb,scomb,[4 4 4]); %smooth with 4mm kernel
    case 'con_smooth_suit'
        
        s = varargin{1};
        
        con=fullfile(suitDir, subj_name{s},'con_0001.nii'); %%contrast smoother
        scon=fullfile(suitDir, subj_name{s},[subj_name{s} '_scon_0001.nii']);
        spm_smooth(con,scon,[4 4 4]); %smooth with 4mm kernel
        
        con=fullfile(suitDir, subj_name{s},'con_0002.nii'); %%contrast smoother
        scon=fullfile(suitDir, subj_name{s},[subj_name{s} '_scon_0002.nii']);
        spm_smooth(con,scon,[4 4 4]); %smooth with 4mm kernel
        
        con=fullfile(suitDir, subj_name{s},'con_0003.nii'); %%contrast smoother
        scon=fullfile(suitDir, subj_name{s},[subj_name{s} '_scon_0003.nii']);
        spm_smooth(con,scon,[4 4 4]); %smooth with 4mm kernel
        
        con=fullfile(suitDir, subj_name{s},'con_0004.nii'); %%contrast smoother
        scon=fullfile(suitDir, subj_name{s},[subj_name{s} '_scon_0004.nii']);
        spm_smooth(con,scon,[4 4 4]); %smooth with 4mm kernel
        
        con=fullfile(suitDir, subj_name{s},'con_0005.nii'); %%contrast smoother
        scon=fullfile(suitDir, subj_name{s},[subj_name{s} '_scon_0005.nii']);
        spm_smooth(con,scon,[4 4 4]); %smooth with 4mm kernel
        
        con=fullfile(suitDir, subj_name{s},'con_0006.nii'); %%contrast smoother
        scon=fullfile(suitDir, subj_name{s},[subj_name{s} '_scon_0006.nii']);
        spm_smooth(con,scon,[4 4 4]); %smooth with 4mm kernel
    case 'suit_normalize' %normalise the isolated cerebellum to the suit atlas - produces 'affine_<source>.mat' and 'u_a_<name>.nii'
        
        sn=varargin{1};
        cd([baseDir '/imaging/anatomicals/' subj_name{sn}]);
        disp(['suit_normalizing ' subj_name{sn}])
        
        gray = {[subj_name{sn} '_anatomical_seg1.nii']}; %grey and white matter images from previous suit stage
        white = {[subj_name{sn} '_anatomical_seg2.nii']};
        isoMask = {['c_' subj_name{sn} '_anatomical_pcereb.nii']}; %isolated cerebellum
        
        job.subjND.gray = gray; %put them all into a struct...
        job.subjND.white = white;
        job.subjND.isolation = isoMask;
        
        suit_normalize_dartel(job) %run the function with the struct as the input
    case 'suit_normalise' %normalisation into suit space
        
        sn=varargin{1};
        cd([baseDir '/imaging/suit/']);
        
        if isfolder(suitGroupDir) == 0
            mkdir(suitGroupDir)
        end
        disp(['suit_reslicing ' subj_name{sn}])
        
        inDir = [suitDir '/' subj_name{sn} '/']; %path to where data is stored (to be normalised)
        outDir = suitGroupDir;
        filenames = {'szacc_Comb_160_Prep', 'szacc_Comb_160_Mov', 'szacc_Spat_160_Prep', 'szacc_Spat_160_Mov', 'szacc_Temp_160_Prep', 'szacc_Temp_160_Mov', 'szacc_Int_160_Prep', 'szacc_Int_160_Mov'};
        
        % prepare files for input
        affine = {[anatDir '/' subj_name{sn} '/' 'Affine_' subj_name{sn} '_anatomical_seg1.mat']};
        flowfield = {[anatDir '/' subj_name{sn} '/' 'u_a_' subj_name{sn} '_anatomical_seg1.nii']};
        
        dataFiles = cell(length(filenames),1); %loop to put all full input file directories into a cell
        for i=1:length(filenames)
            dataFiles{i} = [inDir, subj_name{sn}, '_', filenames{i}, '.nii'];
        end
        
        mask = {[anatDir '/' subj_name{sn} '/' 'c_' subj_name{sn} '_anatomical_pcereb.nii']};
        
        outFiles = cell(length(filenames),1);
        for i=1:length(filenames)
            outFiles{i} = [outDir, '/', filenames{i}, '_', subj_name{sn}, '.nii'];
        end
        
        %% prepare struct for function
        job.subj.affineTr = affine; %fill job.subj. struct with respective items
        job.subj.flowfield = flowfield;
        job.subj.resample = dataFiles;
        job.subj.mask = mask;
        job.subj.outname = outFiles;
        
        %function
        suit_reslice_dartel(job)
    case 'suit_reslice_contrast' %reslice smoothed, normalised, individual contrast maps into SUIT space
        
        sn=varargin{1};
        cd([baseDir '/imaging/suit/' subj_name{sn}]);
        
        disp(['suit_reslicing_contrast ' subj_name{sn}])
        
        inDir = groupDir; %path to where data is stored (to be normalised)
        
        contrasts = {'scon_0001', 'scon_0002', 'scon_0003', 'scon_0004', 'scon_0005', 'scon_0006'};
        
        outDir = suitGroupDir;
        
        % prepare files for input
        affine = {[anatDir '/' subj_name{sn} '/' 'Affine_' subj_name{sn} '_anatomical_seg1.mat']};
        flowfield = {[anatDir '/' subj_name{sn} '/' 'u_a_' subj_name{sn} '_anatomical_seg1.nii']};
        
        dataFiles = cell(length(contrasts),1);
        for i=1:length(contrasts)
            dataFiles{i} = [inDir, '/', contrasts{i}, '_', subj_name{sn} '.nii'];
        end
        
        mask = {[anatDir '/' subj_name{sn} '/' 'c_' subj_name{sn} '_anatomical_pcereb.nii']};
        
        outFiles = cell(length(contrasts),1);
        for i=1:length(contrasts)
            outFiles{i} = [outDir, '/', contrasts{i}, '_', subj_name{sn}, '.nii'];
        end
        
        %%% prepare struct for function
        job.subj.affineTr = affine; %fill job.subj. struct with respective items
        job.subj.flowfield = flowfield;
        job.subj.resample = dataFiles;
        job.subj.mask = mask;
        job.subj.outname = outFiles;
        
        %function
        suit_reslice_dartel(job)
    case 'glm_contrastGroup_suit'
        
        %Produces second-level contrasts. Edit contrast folders, image names, and subject nifti files.
        
        dataDir = {'Mov', 'Prep', 'Error', 'PrepProd', 'ProdPrep', 'Rest'}; %%Save folders for each contrast
        images = {'scon_0001';'scon_0002';'scon_0003';'scon_0004';'scon_0005';'scon_0006'};
        
        subNii = {'_s03.nii','_s05.nii','_s06.nii','_s07.nii','_s09.nii','_s10.nii','_s13.nii','_s16.nii','_s17.nii','_s18.nii','_s20.nii','_s21.nii','_s22.nii','_s25.nii','_s26.nii'...
            '_s31.nii','_s32.nii','_s34.nii','_s36.nii','_s38.nii','_s39.nii','_s40.nii','_s41.nii','_s42.nii'};
        contrastN = length(dataDir);
        images = repmat(images,1,length(subNii));
        subNii = repmat (subNii,length(dataDir),1);
        fileName = strcat (images,subNii);  %%Concatenate contrast files and subject names
        
        for i=1:contrastN  %%Loop across contrasts, plugging parameters into SPM.
            glmscndDir = fullfile(suitScndDir, dataDir(i));
            matlabbatch{1}.spm.stats.factorial_design.dir = glmscndDir;
            matlabbatch{1}.spm.stats.factorial_design.des.t1.scans = fullfile (suitGroupDir, fileName(i,:))';  %%Select files from vectors above
            matlabbatch{1}.spm.stats.factorial_design.cov = struct('c', {}, 'cname', {}, 'iCFI', {}, 'iCC', {});
            matlabbatch{1}.spm.stats.factorial_design.multi_cov = struct('files', {}, 'iCFI', {}, 'iCC', {});
            matlabbatch{1}.spm.stats.factorial_design.masking.tm.tm_none = 1;
            matlabbatch{1}.spm.stats.factorial_design.masking.im = 1;
            matlabbatch{1}.spm.stats.factorial_design.masking.em = {''};
            matlabbatch{1}.spm.stats.factorial_design.globalc.g_omit = 1;
            matlabbatch{1}.spm.stats.factorial_design.globalm.gmsca.gmsca_no = 1;
            matlabbatch{1}.spm.stats.factorial_design.globalm.glonorm = 1;
            
            spm_jobman('run',matlabbatch);  %Run SPM
        end
    case 'glm_contrastEstimate_suit'
        
        dataDir = {'Mov', 'Prep', 'Error', 'PrepProd', 'ProdPrep', 'Rest'}; %%Save folders for each contrast
        contrastN = length(dataDir);
        
        for i=1:contrastN
            matlabbatch{1}.spm.stats.fmri_est.spmmat = fullfile (suitScndDir, dataDir(i), 'SPM.mat');
            matlabbatch{1}.spm.stats.fmri_est.write_residuals = 0;
            matlabbatch{1}.spm.stats.fmri_est.method.Classical = 1;
            
            spm_jobman('run',matlabbatch);
        end
    case 'MVA_group_suit'
        dataDir = {'MVA_comb_mov', 'MVA_comb_prep', 'MVA_int_mov', 'MVA_int_prep', 'MVA_spat_mov', 'MVA_spat_prep','MVA_temp_mov','MVA_temp_prep'}; %%Save folders for each contrast
        images = {'szacc_Comb_160_Mov';'szacc_Comb_160_Prep';'szacc_Int_160_Mov';'szacc_Int_160_Prep';'szacc_Spat_160_Mov';'szacc_Spat_160_Prep';'szacc_Temp_160_Mov';'szacc_Temp_160_Prep'};
        
        %         dataDir = {'MVA_comb_mov', 'MVA_comb_prep'}; %%just overall decoding
        %         images = {'szacc_Comb_160_Mov';'szacc_Comb_160_Prep'};
        
        %ONLY PARTICIPANTS WHO MODULATED TIMING
        subNii = {'_s03.nii','_s05.nii','_s06.nii','_s07.nii','_s09.nii','_s10.nii','_s13.nii','_s16.nii','_s17.nii','_s18.nii','_s20.nii','_s21.nii','_s22.nii','_s25.nii','_s26.nii'...
            '_s31.nii','_s32.nii','_s34.nii','_s36.nii','_s38.nii','_s39.nii','_s40.nii','_s41.nii','_s42.nii'}; %3 5 6 7 9 10 13 16 17 18 20 21 22 25 26 31 32 34 36 38 39 40 41 42
        
        %ALL PARTICIPANTS regardless of timing modulation ***TO DO***
        %         subNii = {'s03.nii','s05.nii','s06.nii','s07.nii','s09.nii','s10.nii','s13.nii','s16.nii','s17.nii','s18.nii','s20.nii','s21.nii','s22.nii','s25.nii','s26.nii'...
        %             's31.nii','s32.nii','s34.nii','s36.nii','s38.nii','s39.nii','s40.nii','s41.nii'}; %3 4 5 6 7 9 10 11 12 13 15 16 17 18 20 21 22 25 26 31 32 33 34 36 37 38 39 40 41 42
        
        contrastN = length(dataDir);
        images = repmat(images,1,length(subNii));
        subNii = repmat (subNii,length(dataDir),1);
        fileName = strcat (images,subNii);  %%Concatenate contrast files and subject names
        
        for i=1:contrastN  %%Loop across contrasts
            glmscndDir = fullfile(suitGroupDir, dataDir(i));
            matlabbatch{1}.spm.stats.factorial_design.dir = glmscndDir;  %Adjust directory
            matlabbatch{1}.spm.stats.factorial_design.des.t1.scans = fullfile (suitGroupDir, fileName(i,:))';  %%Select files from matrix
            matlabbatch{1}.spm.stats.factorial_design.cov = struct('c', {}, 'cname', {}, 'iCFI', {}, 'iCC', {});
            matlabbatch{1}.spm.stats.factorial_design.multi_cov = struct('files', {}, 'iCFI', {}, 'iCC', {});
            matlabbatch{1}.spm.stats.factorial_design.masking.tm.tm_none = 1;
            matlabbatch{1}.spm.stats.factorial_design.masking.im = 1;
            matlabbatch{1}.spm.stats.factorial_design.masking.em = {''};
            matlabbatch{1}.spm.stats.factorial_design.globalc.g_omit = 1;
            matlabbatch{1}.spm.stats.factorial_design.globalm.gmsca.gmsca_no = 1;
            matlabbatch{1}.spm.stats.factorial_design.globalm.glonorm = 1;
            
            spm_jobman('run',matlabbatch);
        end
        
        %AVERAGE GROUP DATA
        %open spm fmri and select 'imcalc'
        %choose all images from participants of interest
        %(i1+i2+i3+i4+i5+i6+i7+i8+i9+i10+i11+i12+i13+i14+i15+i16+i17+i18+i19+i20+i21+i22+i23+i24)/24
        %(i1+i2+i3+i4+i5+i6+i7+i8+i9+i10+i11+i12+i13+i14+i15+i16+i17+i18+i19+i20+i21+i22+i23+i24)/24;
    case 'MVA_estimate_suit'
        dataDir = {'MVA_comb_mov', 'MVA_comb_prep', 'MVA_int_mov', 'MVA_int_prep', 'MVA_spat_mov', 'MVA_spat_prep','MVA_temp_mov','MVA_temp_prep'}; %%Save folders for each contrast
        %         dataDir = {'MVA_comb_mov', 'MVA_comb_prep'}; %%Save folders for each contrast
        contrastN = length(dataDir);
        
        for i=1:contrastN
            matlabbatch{1}.spm.stats.fmri_est.spmmat = fullfile (suitGroupDir, dataDir(i), 'SPM.mat');  %Adjust directory
            matlabbatch{1}.spm.stats.fmri_est.write_residuals = 0;
            matlabbatch{1}.spm.stats.fmri_est.method.Classical = 1;
            
            spm_jobman('run',matlabbatch);
        end
        
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Whole brain image reslicing %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    case 'suit_reslice_whole'
        
        sn=varargin{1};
        cd([baseDir '/imaging/suit/']);
        
        %         if isdir([baseDir '/imaging/suit/' subj_name{sn}]) == 0
        %             mkdir([baseDir '/imaging/suit/' subj_name{sn}])
        %         end
        disp(['suit_reslicing ' subj_name{sn}])
        
        inDir = [glmDir '/' subj_name{sn} '/']; %path to where data is stored (to be normalised)
        outDir = [baseDir '/imaging/suit/'];
        filenames = {'_szacc_Comb_160_Prep.nii', '_szacc_Comb_160_Mov.nii', '_szacc_Spat_160_Prep.nii', '_szacc_Spat_160_Mov.nii', '_szacc_Temp_160_Prep.nii', '_szacc_Temp_160_Mov.nii', '_szacc_Int_160_Prep.nii', '_szacc_Int_160_Mov.nii'};
        filenamesT = {'spmT_0001.nii', 'spmT_0002.nii', 'spmT_0003.nii', 'spmT_0004.nii', 'spmT_0005.nii', 'spmT_0006.nii'};
        
        %% prepare files for input
        affine = {[anatDir '/' subj_name{sn} '/' 'Affine_' subj_name{sn} '_anatomical_seg1.mat']};
        flowfield = {[anatDir '/' subj_name{sn} '/' 'u_a_' subj_name{sn} '_anatomical_seg1.nii']};
        
        dataFiles = cell(length(filenames),1); %separate loops to fill filenames for classifiers and T contrast maps
        for i=1:length(filenames)
            dataFiles{i} = [inDir, subj_name{sn}, filenames{i}];
        end
        dataFilesT = cell(length(filenamesT),1);
        for i=1:length(filenamesT)
            dataFilesT{i} = [inDir, filenamesT{i}];
        end
        dataFiles = [dataFiles; dataFilesT];
        
        mask = {[anatDir '/' subj_name{sn} '/' 'c_' subj_name{sn} '_anatomical_pcereb.nii']};
        
        outFiles = cell(length(filenames),1);
        for i=1:length(filenames)
            outFiles{i} = [outDir, '/', subj_name{sn}, filenames{i}];
        end
        outFilesT = cell(length(filenamesT),1);
        for i=1:length(filenamesT)
            outFilesT{i} = [outDir, '/', subj_name{sn}, '_' filenamesT{i}];
        end
        outFiles = [outFiles; outFilesT];
        
        %% prepare struct for function
        job.subj.affineTr = affine; %fill job.subj. struct with respective items
        job.subj.flowfield = flowfield;
        job.subj.resample = dataFiles;
        job.subj.mask = mask;
        job.subj.outname = outFiles;
        
        %function
        suit_reslice_dartel(job)
    case 'suit_group_whole'
        
        %% Produces second-level contrasts. Edit contrast folders, image names, and subject nifti files.
        
        dataDir = {'Mov', 'Prep', 'Error', 'PrepProd', 'ProdPrep', 'Rest'}; %%Save folders for each contrast
        images = {'_spmT_0001.nii';'_spmT_0002.nii';'_spmT_0003.nii';'_spmT_0004.nii';'_spmT_0005.nii';'_spmT_0006.nii'};
        
        %         dataDir = {'Mov','Prep','Points'}; %%Save folders for each contrast
        %         images = {'scon_0001';'scon_0002';'scon_0006'};
        
        %         dataDir = {'Prep'}; %%Save folders for each contrast
        %         images = {'scon_0002'};
        
        subNii = {'s03','s04','s05','s06','s07','s09','s10','s11'};
        contrastN = length(dataDir);
        images = repmat(images,1,length(subNii));
        subNii = repmat (subNii,length(dataDir),1);
        fileName = strcat (subNii, images);  %%Concatenate contrast files and subject names
        
        for i=1:contrastN  %%Loop across contrasts, plugging parameters into SPM.
            glmscndDir = fullfile(suitDir, 'data', dataDir(i));
            matlabbatch{1}.spm.stats.factorial_design.dir = glmscndDir;
            matlabbatch{1}.spm.stats.factorial_design.des.t1.scans = fullfile (suitDir, fileName(i,:))';  %%Select files from vectors above
            matlabbatch{1}.spm.stats.factorial_design.cov = struct('c', {}, 'cname', {}, 'iCFI', {}, 'iCC', {});
            matlabbatch{1}.spm.stats.factorial_design.multi_cov = struct('files', {}, 'iCFI', {}, 'iCC', {});
            matlabbatch{1}.spm.stats.factorial_design.masking.tm.tm_none = 1;
            matlabbatch{1}.spm.stats.factorial_design.masking.im = 1;
            matlabbatch{1}.spm.stats.factorial_design.masking.em = {''};
            matlabbatch{1}.spm.stats.factorial_design.globalc.g_omit = 1;
            matlabbatch{1}.spm.stats.factorial_design.globalm.gmsca.gmsca_no = 1;
            matlabbatch{1}.spm.stats.factorial_design.globalm.glonorm = 1;
            
            spm_jobman('run',matlabbatch);  %Run SPM
        end
        
        %% Produces second level MVPA accuracy maps. Edit folders, image names, and subject nifti files.
        dataDir = {'MVA_comb_mov', 'MVA_comb_prep', 'MVA_int_mov', 'MVA_int_prep', 'MVA_spat_mov', 'MVA_spat_prep','MVA_temp_mov','MVA_temp_prep'}; %%Save folders for each contrast
        images = {'_szacc_Comb_160_Mov.nii';'_szacc_Comb_160_Prep.nii';'_szacc_Int_160_Mov.nii';'_szacc_Int_160_Prep.nii';'_szacc_Spat_160_Mov.nii';'_szacc_Spat_160_Prep.nii';'_szacc_Temp_160_Mov.nii';'_szacc_Temp_160_Prep.nii'};
        %         subNii = {'_s01.nii','_s02.nii','_s03.nii','_s05.nii','_s06.nii','_s07.nii','_s08.nii','_s09.nii','_s10.nii'};
        subNii = {'s03','s04','s05','s06','s07','s09','s10','s11'};
        contrastN = length(dataDir);
        images = repmat(images,1,length(subNii));
        subNii = repmat (subNii,length(dataDir),1);
        fileName = strcat (subNii, images);  %%Concatenate contrast files and subject names
        
        for i=1:contrastN  %%Loop across contrasts
            glmscndDir = fullfile(suitDir, dataDir(i));
            matlabbatch{1}.spm.stats.factorial_design.dir = glmscndDir;  %Adjust directory
            matlabbatch{1}.spm.stats.factorial_design.des.t1.scans = fullfile (suitDir, fileName(i,:))';  %%Select files from matrix
            matlabbatch{1}.spm.stats.factorial_design.cov = struct('c', {}, 'cname', {}, 'iCFI', {}, 'iCC', {});
            matlabbatch{1}.spm.stats.factorial_design.multi_cov = struct('files', {}, 'iCFI', {}, 'iCC', {});
            matlabbatch{1}.spm.stats.factorial_design.masking.tm.tm_none = 1;
            matlabbatch{1}.spm.stats.factorial_design.masking.im = 1;
            matlabbatch{1}.spm.stats.factorial_design.masking.em = {''};
            matlabbatch{1}.spm.stats.factorial_design.globalc.g_omit = 1;
            matlabbatch{1}.spm.stats.factorial_design.globalm.gmsca.gmsca_no = 1;
            matlabbatch{1}.spm.stats.factorial_design.globalm.glonorm = 1;
            
            spm_jobman('run',matlabbatch);
        end
    case 'suit_estimate_whole'
        
        %%Contrast
        dataDir = {'Mov', 'Prep', 'Error', 'PrepProd', 'ProdPrep', 'Rest'}; %%Save folders for each contrast
        contrastN = length(dataDir);
        
        for i=1:contrastN
            matlabbatch{1}.spm.stats.fmri_est.spmmat = fullfile (suitDir, 'data', dataDir(i), 'SPM.mat');
            matlabbatch{1}.spm.stats.fmri_est.write_residuals = 0;
            matlabbatch{1}.spm.stats.fmri_est.method.Classical = 1;
            
            spm_jobman('run',matlabbatch);
        end
        
        %% MVPA
        dataDir = {'MVA_comb_mov', 'MVA_comb_prep', 'MVA_int_mov', 'MVA_int_prep', 'MVA_spat_mov', 'MVA_spat_prep','MVA_temp_mov','MVA_temp_prep'}; %%Save folders for each contrast
        contrastN = length(dataDir);
        
        for i=1:contrastN
            matlabbatch{1}.spm.stats.fmri_est.spmmat = fullfile (suitDir, dataDir(i), 'SPM.mat');  %Adjust directory
            matlabbatch{1}.spm.stats.fmri_est.write_residuals = 0;
            matlabbatch{1}.spm.stats.fmri_est.method.Classical = 1;
            
            spm_jobman('run',matlabbatch);
        end
    case 'suit_surface_map_whole'
        
        %MANUALLY OPEN RESULTS IN SPM FIRST
        % % SPM -> Results -> suit -> second level folders (contrasts under 'data', MVPA in individual folders.
        dataFolder = {'data/Mov','data/Prep','data/PrepProd','data/ProdPrep','data/Error','data/Rest',... %folders containing data to be projected
            'MVA_comb_mov','MVA_comb_prep','MVA_spat_mov','MVA_spat_prep','MVA_temp_mov','MVA_temp_prep','MVA_int_mov','MVA_int_prep'};
        
        for i =1:length(dataFolder)
            cd([suitDir, '/', dataFolder{i}]) %go into folder location for data and to save into.
            
            flatmapVector = suit_map2surf('spmT_0001.nii'); %produces vector information regarding flatmap
            flatmapGifti = gifti(flatmapVector); %convert to gifti format (compatibility with connectome workbench)
            save(flatmapGifti,'spmT_0001.func.gii')
            save('spmT_0001_flatmap.mat','flatmapVector')
        end
        
        %% for within-matlab visualisation of flatmap, load respective 'spmT_0001_flatmap.mat'
        % then use suit_plotflatmap(flatmapVector, 'cmap', hot, 'cscale', [0 7.00], 'threshold', 3.48) replacing numbers with desired values.
    case 'suit_roi_whole'
        
        dataFolder = {'data/Mov','data/Prep','data/PrepProd','data/ProdPrep','data/Error','data/Rest',... %folders containing data to be projected
            'MVA_comb_mov','MVA_comb_prep','MVA_spat_mov','MVA_spat_prep','MVA_temp_mov','MVA_temp_prep','MVA_int_mov','MVA_int_prep'};
        
        dataNames = {'Mov','Prep','PrepProd','ProdPrep','Error','Rest',... %names for saving
            'MVA_comb_mov','MVA_comb_prep','MVA_spat_mov','MVA_spat_prep','MVA_temp_mov','MVA_temp_prep','MVA_int_mov','MVA_int_prep'};
        
        for i =1:length(dataFolder)
            
            cd([suitDir, '/', dataFolder{i}]) %go into folder location for data.
            saveDir = [suitDir, '/', 'RoI', '/', dataNames{i}, '.txt'];
            filename = {'spmT_0001.nii'};
            
            suit_ROI_summarize(filename, 'outfilename', saveDir) %For definitions of RoIs using standard atlas visit http://www.diedrichsenlab.org/imaging/mdtb.htm
            
        end
        
        
    case 'make_mask_subcorticalSearch'  %SUBCORTICAL SEARCHLIGHT ANALYSIS - Makes restricted analysis mask for MVA
        
        s=varargin{1};
        
        for i=1:length(subcortStructs)
            funMask=fullfile(glmDir, subj_name{s},'maskbrain.nii');
            omask=fullfile(subcorticalSearchDir, subj_name{s},['mr' subj_name{s} '_' subcortStructs{i} '.nii']); %output mask to be used in the future
            subcort = fullfile(subcorticalSearchDir, subj_name{s},['r' subj_name{s} '_' subcortStructs{i} '.nii']);
            
            spm_imcalc({funMask,subcort},omask,'i1 >0.01 & i2 > 0.1',{}); %recorded activity in brain (grey + white matter)
        end
    case 'MVA_search_subcorticalSearch' % Define the search lights for the MVA analysis
        
        s=varargin{1};
        
        for r = 1:length(subcortStructs)
            
            radius=16;
            numVox=160;
            cd(fullfile(subcorticalSearchDir, subj_name{s}));
            V=spm_vol(['mr' subj_name{s} '_' subcortStructs{r} '.nii']); %if preceded by case MVA_mask
            X=spm_read_vols(V);
            [i,j,k]=ind2sub(size(X),find(X~=0));
            vox=[i j k];
            [LI,voxmin,voxmax,n]=lmva_voxelselection(vox(:,:)',vox',[radius numVox],V.mat,V.dim,[],'mva160_numvox.nii');
            save ([subj_name{s} '_' subcortStructs{r} '_' 'volsearch160.mat'], 'vox', 'LI', 'voxmin', 'voxmax', 'n')
        end
    case 'MVA_do_overallMov_subcorticalSearch'                 % Conduct the classification analysis 4 sequences
        
        s=varargin{1};
        
        for r=1:length(subcortStructs);
            
            cd(fullfile(glmDir, subj_name{s}));
            load SPM;
            nrruns=length(SPM.nscan);
            
            
            runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
            prod      =[1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0];
            prod=[repmat(prod,1,nrruns) runBSL];
            
            c=repmat(1:4,1,nrruns); % extract conditions (leave out errors!)
            run=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
            out = {fullfile(subcorticalSearchDir, subj_name{s}, [subj_name{s}, '_' subcortStructs{r} '_accuracy_Comb_160_Mov.nii'])};
            
            
            % Generate column indices for Cross-validation, where
            % cell i contains column indices of the respective test and
            % train set
            for i=1:nrruns
                test{i}=find(run==i);  %fprintf('test:'); display(test{i}');
                train{i}=find(run~=i);  %fprintf('train:'); display(train{i}');
            end;
            
            [row,col] = find(prod>0);
            P={SPM.Vbeta(1:126).fname}';
            Pselect=[];
            for i=1:length(col)
                Pselect{i,1}= P{col(i)};
            end;
            
            tstart = tic
            lmva_spm(fullfile(subcorticalSearchDir,subj_name{s},[subj_name{s} '_' subcortStructs{r} '_volsearch160.mat']),Pselect,out,@combinedclass,'params',{c,run,train,test});
            telapsed = toc(tstart)
        end
    case 'MVA_do_overallPrep_subcorticalSearch'                 % Conduct the classification analysis 4 sequences
        
        s=varargin{1};
        
        for r=1:length(subcortStructs);
            cd(fullfile(glmDir, subj_name{s}));
            load SPM;
            nrruns=length(SPM.nscan);
            
            
            runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
            prep      =[0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0];
            prep=[repmat(prep,1,nrruns) runBSL];
            
            c=repmat(1:4,1,nrruns); % extract conditions (leave out errors!)
            run=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
            out = {fullfile(subcorticalSearchDir, subj_name{s}, [subj_name{s}, '_' subcortStructs{r} '_accuracy_Comb_160_Prep.nii'])};
            
            
            % Generate column indices for Cross-validation, where
            % cell i contains column indices of the respective test and
            % train set
            for i=1:nrruns
                test{i}=find(run==i);  %fprintf('test:'); display(test{i}');
                train{i}=find(run~=i);  %fprintf('train:'); display(train{i}');
            end;
            
            [row,col] = find(prep>0);
            P={SPM.Vbeta(1:126).fname}';
            Pselect=[];
            for i=1:length(col)
                Pselect{i,1}= P{col(i)};
            end;
            
            tstart = tic
            lmva_spm(fullfile(subcorticalSearchDir,subj_name{s},[subj_name{s} '_' subcortStructs{r} '_volsearch160.mat']),Pselect,out,@combinedclass,'params',{c,run,train,test});
            telapsed = toc(tstart)
        end
    case 'MVA_do_spatOneout_Mov_subcorticalSearch'
        
        s=varargin{1};
        
        for r=1:length(subcortStructs);
            cd(fullfile(glmDir, subj_name{s}));
            load SPM;
            nrruns=length(SPM.nscan);
            
            
            runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
            prod      =[1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0];
            prod=[repmat(prod,1,nrruns) runBSL];
            
            c=repmat([1 1 2 2],1,nrruns); % extract conditions (leave out errors!)
            run=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
            out = {fullfile(subcorticalSearchDir, subj_name{s}, [subj_name{s}, '_' subcortStructs{r} '_accuracy_Spat_160_Mov.nii'])};
            
            
            % Generate column indices for cross-validation, where
            % cell i contains column indices of the respective test and
            % train set
            %%%
            oneout=[1 0; 0 1];
            oneout=repmat(oneout,1,12);
            j=0;
            for i=1:2:nrruns*2
                j=j+1;
                test{i}   =find(run==j & oneout(1,:)==1); % Classify S1 vs S2 with T1
                test{i+1} =find(run==j & oneout(2,:)==1); % Classify S1 vs S2 with T2
                
                
                train{i}  =find(run~=j & oneout(1,:)~=1); % Train on S1 vs S2 with T2 ....
                train{i+1}=find(run~=j & oneout(2,:)~=1); % Train on S1 vs S2 with T1 in different runs from testing
                
            end;
            
            [row,col] = find(prod>0);
            P={SPM.Vbeta(1:126).fname}';
            Pselect=[];
            for i=1:length(col)
                Pselect{i,1}= P{col(i)};
            end;
            
            tstart = tic
            lmva_spm(fullfile(subcorticalSearchDir,subj_name{s},[subj_name{s} '_' subcortStructs{r} '_volsearch160.mat']),Pselect,out,@combinedclass,'params',{c,run,train,test});
            telapsed = toc(tstart);
            
        end;
    case 'MVA_do_spatOneout_Prep_subcorticalSearch'
        
        s=varargin{1};
        
        for r=1:length(subcortStructs);
            cd(fullfile(glmDir, subj_name{s}));
            load SPM;
            nrruns=length(SPM.nscan);
            
            
            runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
            prep      =[0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0];
            prep=[repmat(prep,1,nrruns) runBSL];
            
            c=repmat([1 1 2 2],1,nrruns); % extract conditions (leave out errors!)
            run=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
            out = {fullfile(subcorticalSearchDir, subj_name{s}, [subj_name{s}, '_' subcortStructs{r} '_accuracy_Spat_160_Prep.nii'])};
            
            
            % Generate column indices for cross-validation, where
            % cell i contains column indices of the respective test and
            % train set
            %%%
            oneout=[1 0; 0 1];
            oneout=repmat(oneout,1,12);
            j=0;
            for i=1:2:nrruns*2
                j=j+1;
                test{i}   =find(run==j & oneout(1,:)==1); % Classify S1 vs S2 with T1
                test{i+1} =find(run==j & oneout(2,:)==1); % Classify S1 vs S2 with T2
                
                
                train{i}  =find(run~=j & oneout(1,:)~=1); % Train on S1 vs S2 with T2 ....
                train{i+1}=find(run~=j & oneout(2,:)~=1); % Train on S1 vs S2 with T1 in different runs from testing
                
            end;
            
            [row,col] = find(prep>0);
            P={SPM.Vbeta(1:126).fname}';
            Pselect=[];
            for i=1:length(col)
                Pselect{i,1}= P{col(i)};
            end;
            
            tstart = tic
            lmva_spm(fullfile(subcorticalSearchDir,subj_name{s},[subj_name{s} '_' subcortStructs{r} '_volsearch160.mat']),Pselect,out,@combinedclass,'params',{c,run,train,test});
            telapsed = toc(tstart);
            
        end;
    case 'MVA_do_tempOneout_Mov_subcorticalSearch'
        
        s=varargin{1};
        
        for r=1:length(subcortStructs);
            cd(fullfile(glmDir, subj_name{s}));
            load SPM;
            nrruns=length(SPM.nscan);
            
            
            runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
            prod      =[1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0];
            prod=[repmat(prod,1,nrruns) runBSL];
            
            c=repmat([1 2 1 2],1,nrruns); % extract conditions (leave out errors!)
            run=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
            out = {fullfile(subcorticalSearchDir, subj_name{s}, [subj_name{s}, '_' subcortStructs{r} '_accuracy_Temp_160_Mov.nii'])};
            
            
            % Generate column indices for cross-validation, where
            % cell i contains column indices of the respective test and
            % train set
            %%%
            oneout=[1 1 0 0; 0 0 1 1];
            oneout=repmat(oneout,1,6);
            j=0;
            for i=1:2:nrruns*2
                j=j+1;
                test{i}   =find(run==j & oneout(1,:)==1); % Classify S1 vs S2 with T1
                test{i+1} =find(run==j & oneout(2,:)==1); % Classify S1 vs S2 with T2
                
                
                train{i}  =find(run~=j & oneout(1,:)~=1); % Train on S1 vs S2 with T2 ....
                train{i+1}=find(run~=j & oneout(2,:)~=1); % Train on S1 vs S2 with T1 in different runs from testing
                
            end;
            
            [row,col] = find(prod>0);
            P={SPM.Vbeta(1:126).fname}';
            Pselect=[];
            for i=1:length(col)
                Pselect{i,1}= P{col(i)};
            end;
            
            tstart = tic
            lmva_spm(fullfile(subcorticalSearchDir,subj_name{s},[subj_name{s} '_' subcortStructs{r} '_volsearch160.mat']),Pselect,out,@combinedclass,'params',{c,run,train,test});
            telapsed = toc(tstart);
            
        end;
    case 'MVA_do_tempOneout_Prep_subcorticalSearch'
        
        s=varargin{1};
        
        for r=1:length(subcortStructs);
            cd(fullfile(glmDir, subj_name{s}));
            load SPM;
            nrruns=length(SPM.nscan);
            
            
            runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
            prep      =[0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0];
            prep=[repmat(prep,1,nrruns) runBSL];
            
            c=repmat([1 2 1 2],1,nrruns); % extract conditions (leave out errors!)
            run=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
            out = {fullfile(subcorticalSearchDir, subj_name{s}, [subj_name{s}, '_' subcortStructs{r} '_accuracy_Temp_160_Prep.nii'])};
            
            
            % Generate column indices for cross-validation, where
            % cell i contains column indices of the respective test and
            % train set
            %%%
            oneout=[1 1 0 0; 0 0 1 1];
            oneout=repmat(oneout,1,6);
            j=0;
            for i=1:2:nrruns*2
                j=j+1;
                test{i}   =find(run==j & oneout(1,:)==1); % Classify S1 vs S2 with T1
                test{i+1} =find(run==j & oneout(2,:)==1); % Classify S1 vs S2 with T2
                
                
                train{i}  =find(run~=j & oneout(1,:)~=1); % Train on S1 vs S2 with T2 ....
                train{i+1}=find(run~=j & oneout(2,:)~=1); % Train on S1 vs S2 with T1 in different runs from testing
                
            end;
            
            [row,col] = find(prep>0);
            P={SPM.Vbeta(1:126).fname}';
            Pselect=[];
            for i=1:length(col)
                Pselect{i,1}= P{col(i)};
            end;
            
            tstart = tic
            lmva_spm(fullfile(subcorticalSearchDir,subj_name{s},[subj_name{s} '_' subcortStructs{r} '_volsearch160.mat']),Pselect,out,@combinedclass,'params',{c,run,train,test});
            telapsed = toc(tstart);
            
        end;
    case 'MVA_do_Int_Mov_subcorticalSearch'    %'integrated' (subtracts out main effects, i.e. common patterns for T1, T2, S1, S2 and classifies residual)
        s=varargin{1};
        
        for r=1:length(subcortStructs);
            cd(fullfile(glmDir, subj_name{s}));
            load SPM;
            nrruns=length(SPM.nscan);
            
            
            runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
            prod      =[1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0];
            prod=[repmat(prod,1,nrruns) runBSL];
            
            c=repmat(1:4,1,nrruns); % extract conditions (leave out errors!)
            run=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
            out = {fullfile(subcorticalSearchDir, subj_name{s}, [subj_name{s}, '_' subcortStructs{r} '_accuracy_Int_160_Mov.nii'])};
            
            
            % Generate column indices for Cross-validation, where
            % cell i contains column indices of the respective test and
            % train set
            for i=1:nrruns
                test{i}=find(run==i);  %fprintf('test:'); display(test{i}');
                train{i}=find(run~=i);  %fprintf('train:'); display(train{i}');
            end;
            
            [row,col] = find(prod>0);
            P={SPM.Vbeta(1:126).fname}';
            Pselect=[];
            for i=1:length(col)
                Pselect{i,1}= P{col(i)};
            end;
            
            tstart = tic
            lmva_spm(fullfile(subcorticalSearchDir,subj_name{s},[subj_name{s} '_' subcortStructs{r} '_volsearch160.mat'])...
                ,Pselect,out,@prepProd2_combinedclass_corrected4Main,'params',{c,run,train,test});
            telapsed = toc(tstart)
        end
    case 'MVA_do_Int_Prep_subcorticalSearch'    %'integrated' (subtracts out main effects, i.e. common patterns for T1, T2, S1, S2 and classifies residual)
        s=varargin{1};
        
        for r=1:length(subcortStructs)
            cd(fullfile(glmDir, subj_name{s}));
            load SPM;
            nrruns=length(SPM.nscan);
            
            
            runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
            prep      =[0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0];
            prep=[repmat(prep,1,nrruns) runBSL];
            
            c=repmat(1:4,1,nrruns); % extract conditions (leave out errors!)
            run=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
            out = {fullfile(subcorticalSearchDir, subj_name{s}, [subj_name{s}, '_' subcortStructs{r} '_accuracy_Int_160_Prep.nii'])};
            
            
            % Generate column indices for Cross-validation, where
            % cell i contains column indices of the respective test and
            % train set
            for i=1:nrruns
                test{i}=find(run==i);  %fprintf('test:'); display(test{i}');
                train{i}=find(run~=i);  %fprintf('train:'); display(train{i}');
            end;
            
            [row,col] = find(prep>0);
            P={SPM.Vbeta(1:126).fname}';
            Pselect=[];
            for i=1:length(col)
                Pselect{i,1}= P{col(i)};
            end;
            
            tstart = tic
            lmva_spm(fullfile(subcorticalSearchDir,subj_name{s},[subj_name{s} '_' subcortStructs{r} '_volsearch160.mat'])...
                ,Pselect,out,@prepProd2_combinedclass_corrected4Main,'params',{c,run,train,test});
            telapsed = toc(tstart)
        end
        
        
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    case 'MVA_zValue_subcorticalSearch'
        
        s=varargin{1};
        cd(fullfile(subcorticalSearchDir,subj_name{s}));
        
        for r=1:length(subcortStructs)
            
            numTests=6;
            numCat=4;
            mu=1/numCat; %mu=0.25;
            N=numTests*numCat;
            sigma=sqrt(mu*(1-mu)*1/N);
            
            images= {'_accuracy_Comb_160_Mov','_accuracy_Comb_160_Prep','_accuracy_Int_160_Mov','_accuracy_Int_160_Prep'};
            %         images= {'_accuracy_Comb_160_Mov','_accuracy_Comb_160_Prep'};
            
            outimages={'_zacc_Comb_160_Mov','_zacc_Comb_160_Prep','_zacc_Int_160_Mov','_zacc_Int_160_Prep'};
            %         outimages={'_zacc_Comb_160_Mov','_zacc_Comb_160_Prep'};
            
            
            for j=1:numel(images)
                input_image= fullfile([subj_name{s} '_' subcortStructs{r} images{j} '.nii']);
                output_image= fullfile([subj_name{s} '_' subcortStructs{r} outimages{j} '.nii']);
                spmj_imcalc_mtx(input_image, output_image,...
                    sprintf('(X./X).*((X-%d)/%d)',mu, sigma)); %(X./X) acts like a mask! z_accuracy=(accuracy-mu)/sigma;
            end
        end
    case 'MVA_zValue_oneOut_subcorticalSearch'
        
        s=varargin{1};
        cd(fullfile(subcorticalSearchDir,subj_name{s}));
        
        for r=1:length(subcortStructs)
            
            takeOneOutIter=2;
            numTests=6;
            numCat=2;
            mu=1/numCat; %mu=0.5;
            N=numTests*numCat*takeOneOutIter;
            sigma=sqrt(mu*(1-mu)*1/N);
            
            images= {'_accuracy_Spat_160_Mov','_accuracy_Spat_160_Prep','_accuracy_Temp_160_Mov','_accuracy_Temp_160_Prep'};
            
            outimages={'_zacc_Spat_160_Mov','_zacc_Spat_160_Prep','_zacc_Temp_160_Mov','_zacc_Temp_160_Prep'};
            
            
            for j=1:numel(images)
                input_image= fullfile([subj_name{s} '_' subcortStructs{r} images{j} '.nii']);
                output_image= fullfile([subj_name{s} '_' subcortStructs{r} outimages{j} '.nii']);
                spmj_imcalc_mtx(input_image, output_image,...
                    sprintf('(X./X).*((X-%d)/%d)',mu, sigma)); %(X./X) acts like a mask! z_accuracy=(accuracy-mu)/sigma;
            end
        end
    case 'MVA_smooth_subcorticalSearch' %%%Smoothing in subject space
        
        for r=1:length(subcortStructs)
            
            s=varargin{1};
            comb=fullfile(subcorticalSearchDir, subj_name{s},[subj_name{s} '_' subcortStructs{r} '_zacc_Comb_160_Mov.nii']); %%MVPA smoother
            scomb=fullfile(subcorticalSearchDir, subj_name{s},[subj_name{s} '_' subcortStructs{r} '_szacc_Comb_160_Mov.nii']);
            spm_smooth(comb,scomb,[4 4 4]); %smooth with 4mm kernel
            
            s=varargin{1};
            comb=fullfile(subcorticalSearchDir, subj_name{s},[subj_name{s} '_' subcortStructs{r} '_zacc_Comb_160_Prep.nii']); %%MVPA smoother
            scomb=fullfile(subcorticalSearchDir, subj_name{s},[subj_name{s} '_' subcortStructs{r} '_szacc_Comb_160_Prep.nii']);
            spm_smooth(comb,scomb,[4 4 4]); %smooth with 4mm kernel
            
            s=varargin{1};
            comb=fullfile(subcorticalSearchDir, subj_name{s},[subj_name{s} '_' subcortStructs{r} '_zacc_Spat_160_Mov.nii']); %%MVPA smoother
            scomb=fullfile(subcorticalSearchDir, subj_name{s},[subj_name{s} '_' subcortStructs{r} '_szacc_Spat_160_Mov.nii']);
            spm_smooth(comb,scomb,[4 4 4]); %smooth with 4mm kernel
            
            s=varargin{1};
            comb=fullfile(subcorticalSearchDir, subj_name{s},[subj_name{s} '_' subcortStructs{r} '_zacc_Spat_160_Prep.nii']); %%MVPA smoother
            scomb=fullfile(subcorticalSearchDir, subj_name{s},[subj_name{s} '_' subcortStructs{r} '_szacc_Spat_160_Prep.nii']);
            spm_smooth(comb,scomb,[4 4 4]); %smooth with 4mm kernel
            
            s=varargin{1};
            comb=fullfile(subcorticalSearchDir, subj_name{s},[subj_name{s} '_' subcortStructs{r} '_zacc_Temp_160_Mov.nii']); %%MVPA smoother
            scomb=fullfile(subcorticalSearchDir, subj_name{s},[subj_name{s} '_' subcortStructs{r} '_szacc_Temp_160_Mov.nii']);
            spm_smooth(comb,scomb,[4 4 4]); %smooth with 4mm kernel
            
            s=varargin{1};
            comb=fullfile(subcorticalSearchDir, subj_name{s},[subj_name{s} '_' subcortStructs{r} '_zacc_Temp_160_Prep.nii']); %%MVPA smoother
            scomb=fullfile(subcorticalSearchDir, subj_name{s},[subj_name{s} '_' subcortStructs{r} '_szacc_Temp_160_Prep.nii']);
            spm_smooth(comb,scomb,[4 4 4]); %smooth with 4mm kernel
            
            s=varargin{1};
            comb=fullfile(subcorticalSearchDir, subj_name{s},[subj_name{s} '_' subcortStructs{r} '_zacc_Int_160_Mov.nii']); %%MVPA smoother
            scomb=fullfile(subcorticalSearchDir, subj_name{s},[subj_name{s} '_' subcortStructs{r} '_szacc_Int_160_Mov.nii']);
            spm_smooth(comb,scomb,[4 4 4]); %smooth with 4mm kernel
            
            s=varargin{1};
            comb=fullfile(subcorticalSearchDir, subj_name{s},[subj_name{s} '_' subcortStructs{r} '_zacc_Int_160_Prep.nii']); %%MVPA smoother
            scomb=fullfile(subcorticalSearchDir, subj_name{s},[subj_name{s} '_' subcortStructs{r} '_szacc_Int_160_Prep.nii']);
            spm_smooth(comb,scomb,[4 4 4]); %smooth with 4mm kernel
            
            %smooth other images here as required
            
        end
    case 'MNI_normalisation_subcorticalSearch'
        
        s=varargin{1};
        mkdir(fullfile(subcorticalSearchGroupDir,'data')); % folder for each contrast
        
        %MVPA accuracy maps
        images= {'szacc_Comb_160_Mov.nii','szacc_Comb_160_Prep.nii',...
            'szacc_Int_160_Mov.nii','szacc_Int_160_Prep.nii',...
            'szacc_Spat_160_Mov.nii','szacc_Spat_160_Prep.nii',...
            'szacc_Temp_160_Mov.nii','szacc_Temp_160_Prep.nii'}; % please add other images as required, e.g. spmT_...
        
        for r=1:length(subcortStructs)
            for i=1:length(images)
                anaImages{1} = images{i};
                defor= fullfile(anatDir, subj_name{s}, [subj_name{s}, '_anatomical_seg_sn.mat']);
                for j=1:numel(anaImages)
                    [~,name,ext]=spm_fileparts(anaImages{j});
                    sn_images{j}= fullfile(subcorticalSearchDir,subj_name{s},[subj_name{s} '_' subcortStructs{r} '_' anaImages{j}]);
                    out_images{j}= fullfile(subcorticalSearchGroupDir,[name '_' subj_name{s} '_' subcortStructs{r} '.nii']);
                    spmj_normalization_write(defor, sn_images,'outimages',out_images); %Trilinear interpolation
                end
            end
        end
    case 'MVA_group_subcorticalSearch'
        dataDir = {'MVA_comb_mov', 'MVA_comb_prep', 'MVA_int_mov', 'MVA_int_prep', 'MVA_spat_mov', 'MVA_spat_prep','MVA_temp_mov','MVA_temp_prep'}; %%Save folders for each contrast
        images = {'szacc_Comb_160_Mov';'szacc_Comb_160_Prep';'szacc_Int_160_Mov';'szacc_Int_160_Prep';'szacc_Spat_160_Mov';'szacc_Spat_160_Prep';'szacc_Temp_160_Mov';'szacc_Temp_160_Prep'};
        
        %         dataDir = {'MVA_comb_mov', 'MVA_comb_prep'}; %%Save folders for each contrast
        %         images = {'szacc_Comb_160_Mov';'szacc_Comb_160_Prep'};
        
        %ONLY PARTICIPANTS WHO MODULATED TIMING
        subNii = {'_s03.nii','_s05.nii','_s06.nii','_s07.nii','_s09.nii','_s10.nii','_s13.nii','_s16.nii','_s17.nii','_s18.nii','_s20.nii','_s21.nii','_s22.nii','_s25.nii','_s26.nii'...
            '_s31.nii','_s32.nii','_s34.nii','_s36.nii','_s38.nii','_s39.nii','_s40.nii','_s41.nii','_s42.nii'}; %3 5 6 7 9 10 13 16 17 18 20 21 22 25 26 31 32 34 36 38 39 40 41 42
        
        %ALL PARTICIPANTS regardless of timing modulation ***TO DO***
        %         subNii = {'_s03.nii','_s05.nii','_s06.nii','_s07.nii','_s09.nii','_s10.nii','_s13.nii','_s16.nii','_s17.nii','_s18.nii','_s20.nii','_s21.nii','_s22.nii','_s25.nii','_s26.nii'...
        %             '_s31.nii','_s32.nii','_s34.nii','_s36.nii','_s38.nii','_s39.nii','_s40.nii','_s41.nii'}; %3 4 5 6 7 9 10 11 12 13 15 16 17 18 20 21 22 25 26 31 32 33 34 36 37 38 39 40 41 42
        
        contrastN = length(dataDir);
        images = repmat(images,1,length(subNii));
        subNii = repmat (subNii,length(dataDir),1);
        fileName = strcat (images,subNii);  %%Concatenate contrast files and subject names
        
        for i=1:contrastN  %%Loop across contrasts
            glmscndDir = fullfile(subcorticalSearchGroupDir, dataDir(i));
            matlabbatch{1}.spm.stats.factorial_design.dir = glmscndDir;  %Adjust directory
            matlabbatch{1}.spm.stats.factorial_design.des.t1.scans = fullfile (subcorticalSearchGroupDir, fileName(i,:))';  %%Select files from matrix
            matlabbatch{1}.spm.stats.factorial_design.cov = struct('c', {}, 'cname', {}, 'iCFI', {}, 'iCC', {});
            matlabbatch{1}.spm.stats.factorial_design.multi_cov = struct('files', {}, 'iCFI', {}, 'iCC', {});
            matlabbatch{1}.spm.stats.factorial_design.masking.tm.tm_none = 1;
            matlabbatch{1}.spm.stats.factorial_design.masking.im = 1;
            matlabbatch{1}.spm.stats.factorial_design.masking.em = {''};
            matlabbatch{1}.spm.stats.factorial_design.globalc.g_omit = 1;
            matlabbatch{1}.spm.stats.factorial_design.globalm.gmsca.gmsca_no = 1;
            matlabbatch{1}.spm.stats.factorial_design.globalm.glonorm = 1;
            
            spm_jobman('run',matlabbatch);
        end
        
        %AVERAGE GROUP DATA
        %open spm fmri and select 'imcalc'
        %choose all images from participants of interest
        %(i1+i2+i3+i4+i5+i6+i7+i8+i9+i10+i11+i12+i13+i14+i15+16+i17+i18+i19+i20+i21+i22+i23+i24)/24
        
    case 'make_mask_subcorticalArea'  %SUBCORTICAL SEARCHLIGHT ANALYSIS - Makes restricted analysis mask for MVA
        
        s=varargin{1};
        
        for i=1:length(allSubcortStructs);
            funMask=fullfile(glmDir, subj_name{s},'maskbrain.nii');
            omask=fullfile(subcorticalAreaDir, subj_name{s},['mr' subj_name{s} '_' allSubcortStructs{i} '.nii']); %output mask to be used in the future
            subcort = fullfile(subcorticalAreaDir, subj_name{s},['r' subj_name{s} '_' allSubcortStructs{i} '.nii']);
            
            spm_imcalc({funMask,subcort},omask,'i1 >0.01 & i2 > 0.1',{}); %recorded activity in brain (grey + white matter)
        end
    case 'subcortical_define_mva_area' %SUBCORTICAL AREA ANALYSIS - defines area in each subcortical region to be passed to later MVA cases
        
        s=varargin{1};
        
        % load respective subcortical .nii and extract x y z coordinates for voxels
        for r=1:length(subcortStructs)
            cd(fullfile(subcorticalAreaDir, subj_name{s}));
            V=spm_vol(['mr' subj_name{s} '_' subcortStructs{r} '.nii']);
            X=spm_read_vols(V);
            [i,j,k]=ind2sub(size(X),find(X~=0));
            vox=[i j k];
            
            LI{1} = sub2ind(V.dim,vox(:,1),vox(:,2),vox(:,3)); %convert x y z coordinates into linear index for voxels
            voxmin = min(vox,[],1); %min x y z coordinates for each voxel
            voxmax = max(vox,[],1); %max as above
            n = size(vox,1); %number of voxels
            
            save(sprintf('%s_decodeArea_%s.mat',subj_name{s},subcortStructs{r}), 'vox', 'LI', 'voxmin', 'voxmax', 'n')
            disp([subcortStructs{r} ' done'])
        end
    case 'MVA_do_overallMov_subcorticalArea' %runs combMov LDA on all voxels within each subcortical region
        
        s=varargin{1};
        
        cd(fullfile(glmDir, subj_name{s})); %load SPM data
        load SPM;
        nrruns=length(SPM.nscan);
        
        runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
        prod      =[1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0];
        prod=[repmat(prod,1,nrruns) runBSL];
        
        c=repmat(1:4,1,nrruns); % extract conditions (leave out errors!)
        run=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
        
        % Generate column indices for Cross-validation, where
        % cell i contains column indices of the respective test and
        % train set
        for i=1:nrruns
            test{i}=find(run==i);  %fprintf('test:'); display(test{i}');
            train{i}=find(run~=i);  %fprintf('train:'); display(train{i}');
        end;
        
        [~,col] = find(prod>0); %identify relevant beta files and assign to pselect
        P={SPM.Vbeta(1:126).fname}';
        Pselect=[];
        for i=1:length(col)
            Pselect{i,1}= P{col(i)};
        end
        
        predcat = zeros(length(subcortStructs),1);
        
        %%% loop across decoding areas for respective subcortical regions
        for r=1:length(subcortStructs)
            
            S = load(fullfile(subcorticalAreaDir,subj_name{s},[subj_name{s} '_decodeArea_' subcortStructs{r} '.mat']));
            Vin = spm_vol(char(Pselect));
            
            %extract voxels in decoding area from beta files and pass to MVPA function
            linVox=unique(cat(2,S.LI{:})');
            [I,J,K]=ind2sub(Vin(1).dim,linVox);
            X = zeros(length(linVox),length(Vin));
            
            for i=1:length(Vin) %this gives us a voxelN x betaN matrix
                X(:,i)=spm_sample_vol(Vin(i),double(I),double(J),double(K),0);
            end
            
            [nanidx, ~] = find(isnan(X)); %remove nan values contained in beta image due to signal loss(?)
            nanidx = unique(nanidx);
            X(nanidx,:) = [];
            
            pred = combinedclass(X, c, run, train, test); %classifier function which gives us accuracy value as a decimal
            % chance value = 0.25
            %             disp(['Prediction value ' num2str(pred) ' in ' subcortStructs{r}]) %display all in window
            
            predcat(r) = pred; %save prediction value into variable
        end
        
        combMov = [subcortStructs', num2cell(predcat)]; %save participant's decoding values to .mat file
        cd([subcorticalAreaDir, '/', subj_name{s}])
        save([subj_name{s}, '_combMov_subcortical'],'combMov')
    case 'MVA_do_overallPrep_subcorticalArea' %runs combPrep LDA on all voxels within each subcortical region
        
        s=varargin{1};
        
        cd(fullfile(glmDir, subj_name{s}));
        load SPM;
        nrruns=length(SPM.nscan);
        
        runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
        prep      =[0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0];
        prep=[repmat(prep,1,nrruns) runBSL];
        
        c=repmat(1:4,1,nrruns); % extract conditions (leave out errors!)
        run=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
        
        % Generate column indices for Cross-validation, where
        % cell i contains column indices of the respective test and
        % train set
        for i=1:nrruns
            test{i}=find(run==i);  %fprintf('test:'); display(test{i}');
            train{i}=find(run~=i);  %fprintf('train:'); display(train{i}');
        end;
        
        [row,col] = find(prep>0);
        P={SPM.Vbeta(1:126).fname}';
        Pselect=[];
        for i=1:length(col)
            Pselect{i,1}= P{col(i)};
        end;
        
        predcat = zeros(length(subcortStructs),1);
        
        %%% loop across decoding areas for respective subcortical regions
        for r=1:length(subcortStructs)
            
            S = load(fullfile(subcorticalAreaDir,subj_name{s},[subj_name{s} '_decodeArea_' subcortStructs{r} '.mat']));
            Vin = spm_vol(char(Pselect));
            
            %extract voxels in decoding area from beta files and pass to MVPA function
            linVox=unique(cat(2,S.LI{:})');
            [I,J,K]=ind2sub(Vin(1).dim,linVox);
            X = zeros(length(linVox),length(Vin));
            
            for i=1:length(Vin) %this gives us a voxelN x betaN matrix
                X(:,i)=spm_sample_vol(Vin(i),double(I),double(J),double(K),0);
            end
            
            [nanidx, ~] = find(isnan(X)); %remove nan values contained in beta image due to signal loss(?)
            nanidx = unique(nanidx);
            X(nanidx,:) = [];
            
            pred = combinedclass(X, c, run, train, test); %classifier function which gives us accuracy value as a decimal
            % chance value = 0.25
            %             disp(['Prediction value ' num2str(pred) ' in ' subcortStructs{r}]) %display all in window
            
            %%%TO DO%%%
            predcat(r) = pred; %save prediction value into variable
        end
        
        combPrep = [subcortStructs', num2cell(predcat)]; %save participant's decoding values to .mat file
        cd([subcorticalAreaDir, '/', subj_name{s}])
        save([subj_name{s}, '_combPrep_subcortical'],'combPrep')
    case 'MVA_do_spatOneout_Mov_subcorticalArea' %runs spatMov LDA on all voxels within each subcortical region
        
        s=varargin{1};
        
        cd(fullfile(glmDir, subj_name{s}));
        load SPM;
        nrruns=length(SPM.nscan);
        
        runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
        prod      =[1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0];
        prod=[repmat(prod,1,nrruns) runBSL];
        
        c=repmat([1 1 2 2],1,nrruns); % extract conditions (leave out errors!)
        run=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
        
        % Generate column indices for cross-validation, where
        % cell i contains column indices of the respective test and
        % train set
        %%%
        oneout=[1 0; 0 1];
        oneout=repmat(oneout,1,12);
        j=0;
        for i=1:2:nrruns*2
            j=j+1;
            test{i}   =find(run==j & oneout(1,:)==1); % Classify S1 vs S2 with T1
            test{i+1} =find(run==j & oneout(2,:)==1); % Classify S1 vs S2 with T2
            
            
            train{i}  =find(run~=j & oneout(1,:)~=1); % Train on S1 vs S2 with T2 ....
            train{i+1}=find(run~=j & oneout(2,:)~=1); % Train on S1 vs S2 with T1 in different runs from testing
            
        end;
        
        [row,col] = find(prod>0);
        P={SPM.Vbeta(1:126).fname}';
        Pselect=[];
        for i=1:length(col)
            Pselect{i,1}= P{col(i)};
        end;
        predcat = zeros(length(subcortStructs),1);
        
        %%% loop across decoding areas for respective subcortical regions
        for r=1:length(subcortStructs)
            
            S = load(fullfile(subcorticalAreaDir,subj_name{s},[subj_name{s} '_decodeArea_' subcortStructs{r} '.mat']));
            Vin = spm_vol(char(Pselect));
            
            %extract voxels in decoding area from beta files and pass to MVPA function
            linVox=unique(cat(2,S.LI{:})');
            [I,J,K]=ind2sub(Vin(1).dim,linVox);
            X = zeros(length(linVox),length(Vin));
            
            for i=1:length(Vin) %this gives us a voxelN x betaN matrix
                X(:,i)=spm_sample_vol(Vin(i),double(I),double(J),double(K),0);
            end
            
            [nanidx, ~] = find(isnan(X)); %remove nan values contained in beta image due to signal loss(?)
            nanidx = unique(nanidx);
            X(nanidx,:) = [];
            
            pred = combinedclass(X, c, run, train, test); %classifier function which gives us accuracy value as a decimal
            % chance value = 0.25
            %             disp(['Prediction value ' num2str(pred) ' in ' subcortStructs{r}]) %display all in window
            
            %%%TO DO%%%
            predcat(r) = pred; %save prediction value into variable
        end
        
        spatMov = [subcortStructs', num2cell(predcat)]; %save participant's decoding values to .mat file
        cd([subcorticalAreaDir, '/', subj_name{s}])
        save([subj_name{s}, '_spatMov_subcortical'],'spatMov')
    case 'MVA_do_spatOneout_Prep_subcorticalArea' %runs spatPrep LDA on all voxels within each subcortical region
        
        s=varargin{1};
        
        cd(fullfile(glmDir, subj_name{s}));
        load SPM;
        nrruns=length(SPM.nscan);
        
        
        runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
        prep      =[0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0];
        prep=[repmat(prep,1,nrruns) runBSL];
        
        c=repmat([1 1 2 2],1,nrruns); % extract conditions (leave out errors!)
        run=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
        out = {fullfile(glmDir, subj_name{s}, [subj_name{s}, '_accuracy_Spat_160_Prep.nii'])};
        
        
        % Generate column indices for cross-validation, where
        % cell i contains column indices of the respective test and
        % train set
        %%%
        oneout=[1 0; 0 1];
        oneout=repmat(oneout,1,12);
        j=0;
        for i=1:2:nrruns*2
            j=j+1;
            test{i}   =find(run==j & oneout(1,:)==1); % Classify S1 vs S2 with T1
            test{i+1} =find(run==j & oneout(2,:)==1); % Classify S1 vs S2 with T2
            
            
            train{i}  =find(run~=j & oneout(1,:)~=1); % Train on S1 vs S2 with T2 ....
            train{i+1}=find(run~=j & oneout(2,:)~=1); % Train on S1 vs S2 with T1 in different runs from testing
            
        end;
        
        [row,col] = find(prep>0);
        P={SPM.Vbeta(1:126).fname}';
        Pselect=[];
        for i=1:length(col)
            Pselect{i,1}= P{col(i)};
        end;
        
        predcat = zeros(length(subcortStructs),1);
        
        %%% loop across decoding areas for respective subcortical regions
        for r=1:length(subcortStructs)
            
            S = load(fullfile(subcorticalAreaDir,subj_name{s},[subj_name{s} '_decodeArea_' subcortStructs{r} '.mat']));
            Vin = spm_vol(char(Pselect));
            
            %extract voxels in decoding area from beta files and pass to MVPA function
            linVox=unique(cat(2,S.LI{:})');
            [I,J,K]=ind2sub(Vin(1).dim,linVox);
            X = zeros(length(linVox),length(Vin));
            
            for i=1:length(Vin) %this gives us a voxelN x betaN matrix
                X(:,i)=spm_sample_vol(Vin(i),double(I),double(J),double(K),0);
            end
            
            [nanidx, ~] = find(isnan(X)); %remove nan values contained in beta image due to signal loss(?)
            nanidx = unique(nanidx);
            X(nanidx,:) = [];
            
            pred = combinedclass(X, c, run, train, test); %classifier function which gives us accuracy value as a decimal
            % chance value = 0.25
            %             disp(['Prediction value ' num2str(pred) ' in ' subcortStructs{r}]) %display all in window
            
            %%%TO DO%%%
            predcat(r) = pred; %save prediction value into variable
        end
        
        spatPrep = [subcortStructs', num2cell(predcat)]; %save participant's decoding values to .mat file
        cd([subcorticalAreaDir, '/', subj_name{s}])
        save([subj_name{s}, '_spatPrep_subcortical'],'spatPrep')
    case 'MVA_do_tempOneout_Mov_subcorticalArea' %runs tempMov LDA on all voxels within each subcortical region
        s=varargin{1};
        
        cd(fullfile(glmDir, subj_name{s}));
        load SPM;
        nrruns=length(SPM.nscan);
        
        
        runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
        prod      =[1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0];
        prod=[repmat(prod,1,nrruns) runBSL];
        
        c=repmat([1 2 1 2],1,nrruns); % extract conditions (leave out errors!)
        run=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
        
        % Generate column indices for cross-validation, where
        % cell i contains column indices of the respective test and
        % train set
        %%%
        oneout=[1 1 0 0; 0 0 1 1];
        oneout=repmat(oneout,1,6);
        j=0;
        for i=1:2:nrruns*2
            j=j+1;
            test{i}   =find(run==j & oneout(1,:)==1); % Classify S1 vs S2 with T1
            test{i+1} =find(run==j & oneout(2,:)==1); % Classify S1 vs S2 with T2
            
            
            train{i}  =find(run~=j & oneout(1,:)~=1); % Train on S1 vs S2 with T2 ....
            train{i+1}=find(run~=j & oneout(2,:)~=1); % Train on S1 vs S2 with T1 in different runs from testing
            
        end;
        
        [row,col] = find(prod>0);
        P={SPM.Vbeta(1:126).fname}';
        Pselect=[];
        for i=1:length(col)
            Pselect{i,1}= P{col(i)};
        end;
        
        predcat = zeros(length(subcortStructs),1);
        
        %%% loop across decoding areas for respective subcortical regions
        for r=1:length(subcortStructs)
            
            S = load(fullfile(subcorticalAreaDir,subj_name{s},[subj_name{s} '_decodeArea_' subcortStructs{r} '.mat']));
            Vin = spm_vol(char(Pselect));
            
            %extract voxels in decoding area from beta files and pass to MVPA function
            linVox=unique(cat(2,S.LI{:})');
            [I,J,K]=ind2sub(Vin(1).dim,linVox);
            X = zeros(length(linVox),length(Vin));
            
            for i=1:length(Vin) %this gives us a voxelN x betaN matrix
                X(:,i)=spm_sample_vol(Vin(i),double(I),double(J),double(K),0);
            end
            
            [nanidx, ~] = find(isnan(X)); %remove nan values contained in beta image due to signal loss(?)
            nanidx = unique(nanidx);
            X(nanidx,:) = [];
            
            pred = combinedclass(X, c, run, train, test); %classifier function which gives us accuracy value as a decimal
            % chance value = 0.25
            %             disp(['Prediction value ' num2str(pred) ' in ' subcortStructs{r}]) %display all in window
            
            %%%TO DO%%%
            predcat(r) = pred; %save prediction value into variable
        end
        
        tempMov = [subcortStructs', num2cell(predcat)]; %save participant's decoding values to .mat file
        cd([subcorticalAreaDir, '/', subj_name{s}])
        save([subj_name{s}, '_tempMov_subcortical'],'tempMov')
    case 'MVA_do_tempOneout_Prep_subcorticalArea' %runs tempPrep LDA on all voxels within each subcortical region
        s=varargin{1};
        
        cd(fullfile(glmDir, subj_name{s}));
        load SPM;
        nrruns=length(SPM.nscan);
        
        
        runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
        prep      =[0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0];
        prep=[repmat(prep,1,nrruns) runBSL];
        
        c=repmat([1 2 1 2],1,nrruns); % extract conditions (leave out errors!)
        run=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
        
        % Generate column indices for cross-validation, where
        % cell i contains column indices of the respective test and
        % train set
        %%%
        oneout=[1 1 0 0; 0 0 1 1];
        oneout=repmat(oneout,1,6);
        j=0;
        for i=1:2:nrruns*2
            j=j+1;
            test{i}   =find(run==j & oneout(1,:)==1); % Classify S1 vs S2 with T1
            test{i+1} =find(run==j & oneout(2,:)==1); % Classify S1 vs S2 with T2
            
            
            train{i}  =find(run~=j & oneout(1,:)~=1); % Train on S1 vs S2 with T2 ....
            train{i+1}=find(run~=j & oneout(2,:)~=1); % Train on S1 vs S2 with T1 in different runs from testing
            
        end;
        
        [row,col] = find(prep>0);
        P={SPM.Vbeta(1:126).fname}';
        Pselect=[];
        for i=1:length(col)
            Pselect{i,1}= P{col(i)};
        end;
        
        predcat = zeros(length(subcortStructs),1);
        
        %%% loop across decoding areas for respective subcortical regions
        for r=1:length(subcortStructs)
            
            S = load(fullfile(subcorticalAreaDir,subj_name{s},[subj_name{s} '_decodeArea_' subcortStructs{r} '.mat']));
            Vin = spm_vol(char(Pselect));
            
            %extract voxels in decoding area from beta files and pass to MVPA function
            linVox=unique(cat(2,S.LI{:})');
            [I,J,K]=ind2sub(Vin(1).dim,linVox);
            X = zeros(length(linVox),length(Vin));
            
            for i=1:length(Vin) %this gives us a voxelN x betaN matrix
                X(:,i)=spm_sample_vol(Vin(i),double(I),double(J),double(K),0);
            end
            
            [nanidx, ~] = find(isnan(X)); %remove nan values contained in beta image due to signal loss(?)
            nanidx = unique(nanidx);
            X(nanidx,:) = [];
            
            pred = combinedclass(X, c, run, train, test); %classifier function which gives us accuracy value as a decimal
            % chance value = 0.25
            %             disp(['Prediction value ' num2str(pred) ' in ' subcortStructs{r}]) %display all in window
            
            %%%TO DO%%%
            predcat(r) = pred; %save prediction value into variable
        end
        
        tempPrep = [subcortStructs', num2cell(predcat)]; %save participant's decoding values to .mat file
        cd([subcorticalAreaDir, '/', subj_name{s}])
        save([subj_name{s}, '_tempPrep_subcortical'],'tempPrep')
    case 'MVA_do_Int_Mov_subcorticalArea' %runs intMov LDA on all voxels within each subcortical region
        
        s=varargin{1};
        
        cd(fullfile(glmDir, subj_name{s})); %load SPM data
        load SPM;
        nrruns=length(SPM.nscan);
        
        runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
        prod      =[1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0];
        prod=[repmat(prod,1,nrruns) runBSL];
        
        c=repmat(1:4,1,nrruns); % extract conditions (leave out errors!)
        run=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
        
        % Generate column indices for Cross-validation, where
        % cell i contains column indices of the respective test and
        % train set
        for i=1:nrruns
            test{i}=find(run==i);  %fprintf('test:'); display(test{i}');
            train{i}=find(run~=i);  %fprintf('train:'); display(train{i}');
        end;
        
        [~,col] = find(prod>0); %identify relevant beta files and assign to pselect
        P={SPM.Vbeta(1:126).fname}';
        Pselect=[];
        for i=1:length(col)
            Pselect{i,1}= P{col(i)};
        end
        
        predcat = zeros(length(subcortStructs),1);
        
        %%% loop across decoding areas for respective subcortical regions
        for r=1:length(subcortStructs)
            
            S = load(fullfile(subcorticalAreaDir,subj_name{s},[subj_name{s} '_decodeArea_' subcortStructs{r} '.mat']));
            Vin = spm_vol(char(Pselect));
            
            %extract voxels in decoding area from beta files and pass to MVPA function
            linVox=unique(cat(2,S.LI{:})');
            [I,J,K]=ind2sub(Vin(1).dim,linVox);
            X = zeros(length(linVox),length(Vin));
            
            for i=1:length(Vin) %this gives us a voxelN x betaN matrix
                X(:,i)=spm_sample_vol(Vin(i),double(I),double(J),double(K),0);
            end
            
            [nanidx, ~] = find(isnan(X)); %remove nan values contained in beta image due to signal loss(?)
            nanidx = unique(nanidx);
            X(nanidx,:) = [];
            
            pred = prepProd2_combinedclass_corrected4Main(X, c, run, train, test); %classifier function which gives us accuracy value as a decimal
            % chance value = 0.25
            %             disp(['Prediction value ' num2str(pred) ' in ' subcortStructs{r}]) %display all in window
            
            predcat(r) = pred; %save prediction value into variable
        end
        
        intMov = [subcortStructs', num2cell(predcat)]; %save participant's decoding values to .mat file
        cd([subcorticalAreaDir, '/', subj_name{s}])
        save([subj_name{s}, '_intMov_subcortical'],'intMov')
    case 'MVA_do_Int_Prep_subcorticalArea' %runs intPrep LDA on all voxels within each subcortical region
        
        s=varargin{1};
        
        cd(fullfile(glmDir, subj_name{s}));
        load SPM;
        nrruns=length(SPM.nscan);
        
        runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
        prep      =[0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0];
        prep=[repmat(prep,1,nrruns) runBSL];
        
        c=repmat(1:4,1,nrruns); % extract conditions (leave out errors!)
        run=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
        
        % Generate column indices for Cross-validation, where
        % cell i contains column indices of the respective test and
        % train set
        for i=1:nrruns
            test{i}=find(run==i);  %fprintf('test:'); display(test{i}');
            train{i}=find(run~=i);  %fprintf('train:'); display(train{i}');
        end;
        
        [row,col] = find(prep>0);
        P={SPM.Vbeta(1:126).fname}';
        Pselect=[];
        for i=1:length(col)
            Pselect{i,1}= P{col(i)};
        end;
        
        predcat = zeros(length(subcortStructs),1);
        
        %%% loop across decoding areas for respective subcortical regions
        for r=1:length(subcortStructs)
            
            S = load(fullfile(subcorticalAreaDir,subj_name{s},[subj_name{s} '_decodeArea_' subcortStructs{r} '.mat']));
            Vin = spm_vol(char(Pselect));
            
            %extract voxels in decoding area from beta files and pass to MVPA function
            linVox=unique(cat(2,S.LI{:})');
            [I,J,K]=ind2sub(Vin(1).dim,linVox);
            X = zeros(length(linVox),length(Vin));
            
            for i=1:length(Vin) %this gives us a voxelN x betaN matrix
                X(:,i)=spm_sample_vol(Vin(i),double(I),double(J),double(K),0);
            end
            
            [nanidx, ~] = find(isnan(X)); %remove nan values contained in beta image due to signal loss(?)
            nanidx = unique(nanidx);
            X(nanidx,:) = [];
            
            pred = prepProd2_combinedclass_corrected4Main(X, c, run, train, test); %classifier function which gives us accuracy value as a decimal
            % chance value = 0.25
            %             disp(['Prediction value ' num2str(pred) ' in ' subcortStructs{r}]) %display all in window
            
            %%%TO DO%%%
            predcat(r) = pred; %save prediction value into variable
        end
        
        intPrep = [subcortStructs', num2cell(predcat)]; %save participant's decoding values to .mat file
        cd([subcorticalAreaDir, '/', subj_name{s}])
        save([subj_name{s}, '_intPrep_subcortical'],'intPrep')
    case 'MVA_group_subcorticalArea'
        
        classifiers = {'combMov', 'combPrep', 'spatMov', 'spatPrep', 'tempMov', 'tempPrep', 'intMov', 'intPrep'};
        combMovGroup = subcortStructs'; combPrepGroup = subcortStructs'; spatMovGroup = subcortStructs'; spatPrepGroup = subcortStructs';
        tempMovGroup = subcortStructs'; tempPrepGroup = subcortStructs'; intMovGroup = subcortStructs'; intPrepGroup = subcortStructs';
        
        for s = anaSubj(1:end ~= 2)
            cd(fullfile(subcorticalAreaDir, subj_name{s}))
            load([subj_name{s} '_combMov_subcortical.mat']); load([subj_name{s} '_combPrep_subcortical.mat'])
            load([subj_name{s} '_spatMov_subcortical.mat']); load([subj_name{s} '_spatPrep_subcortical.mat'])
            load([subj_name{s} '_tempMov_subcortical.mat']); load([subj_name{s} '_tempPrep_subcortical.mat'])
            load([subj_name{s} '_intMov_subcortical.mat']); load([subj_name{s} '_intPrep_subcortical.mat'])
            
            combMovGroup = [combMovGroup combMov(:,2)]; combPrepGroup = [combPrepGroup combPrep(:,2)];
            spatMovGroup = [spatMovGroup spatMov(:,2)]; spatPrepGroup = [spatPrepGroup spatPrep(:,2)];
            tempMovGroup = [tempMovGroup tempMov(:,2)]; tempPrepGroup = [tempPrepGroup tempPrep(:,2)];
            intMovGroup = [intMovGroup intMov(:,2)]; intPrepGroup = [intPrepGroup intPrep(:,2)];
            
        end
        
        cd(subcorticalAreaDir)
        save('combMov_subcortical', 'combMovGroup'); save('combPrep_subcortical', 'combPrepGroup')
        save('spatMov_subcortical', 'spatMovGroup'); save('spatPrep_subcortical', 'spatPrepGroup')
        save('tempMov_subcortical', 'tempMovGroup'); save('tempPrep_subcortical', 'tempPrepGroup')
        save('intMov_subcortical', 'intMovGroup'); save('intPrep_subcortical', 'intPrepGroup')
    case 'MVA_zacc_subcorticalArea'
        
        %%% 25% chance
        cd(subcorticalAreaDir);
        
        load('combMov_subcortical.mat'); load('combPrep_subcortical.mat')
        load('intMov_subcortical.mat'); load('intPrep_subcortical.mat')
        
        numTests=6;
        numCat=4;
        mu=1/numCat; %mu=0.25;
        N=numTests*numCat;
        sigma=sqrt(mu*(1-mu)*1/N);
        
        %         sprintf('(X./X).*((X-%d)/%d)',mu, sigma); %(X./X) acts like a mask! z_accuracy=(accuracy-mu)/sigma;
        combMovGroupZacc = (cell2mat(combMovGroup(:,2:24))-mu)/sigma;
        combPrepGroupZacc = (cell2mat(combPrepGroup(:,2:24))-mu)/sigma;
        intMovGroupZacc = (cell2mat(intMovGroup(:,2:24))-mu)/sigma;
        intPrepGroupZacc = (cell2mat(intPrepGroup(:,2:24))-mu)/sigma;
        
        combMovGroupZacc = [combMovGroup(:,1), num2cell(combMovGroupZacc)]';
        combPrepGroupZacc = [combPrepGroup(:,1), num2cell(combPrepGroupZacc)]';
        intMovGroupZacc = [intMovGroup(:,1), num2cell(intMovGroupZacc)]';
        intPrepGroupZacc = [intPrepGroup(:,1), num2cell(intPrepGroupZacc)]';
        
        save('zacc_combMov_subcortical', 'combMovGroupZacc'); save('zacc_combPrep_subcortical', 'combPrepGroupZacc')
        save('zacc_intMov_subcortical', 'intMovGroupZacc'); save('zacc_intPrep_subcortical', 'intPrepGroupZacc')
        
        xlswrite('zacc_combMov_subcortical', combMovGroupZacc); xlswrite('zacc_combPrep_subcortical', combPrepGroupZacc)
        xlswrite('zacc_intMov_subcortical', intMovGroupZacc); xlswrite('zacc_intPrep_subcortical', intPrepGroupZacc)
        
        %%% 50% chance
        cd(subcorticalAreaDir);
        
        load('spatMov_subcortical.mat'); load('spatPrep_subcortical.mat')
        load('tempMov_subcortical.mat'); load('tempPrep_subcortical.mat')
        
        takeOneOutIter=2;
        numTests=6;
        numCat=2;
        mu=1/numCat; %mu=0.5;
        N=numTests*numCat*takeOneOutIter;
        sigma=sqrt(mu*(1-mu)*1/N);
        
        %         sprintf('(X./X).*((X-%d)/%d)',mu, sigma); %(X./X) acts like a mask! z_accuracy=(accuracy-mu)/sigma;
        spatMovGroupZacc = (cell2mat(spatMovGroup(:,2:24))-mu)/sigma;
        spatPrepGroupZacc = (cell2mat(spatPrepGroup(:,2:24))-mu)/sigma;
        tempMovGroupZacc = (cell2mat(tempMovGroup(:,2:24))-mu)/sigma;
        tempPrepGroupZacc = (cell2mat(tempPrepGroup(:,2:24))-mu)/sigma;
        
        spatMovGroupZacc = [spatMovGroup(:,1), num2cell(spatMovGroupZacc)]';
        spatPrepGroupZacc = [spatPrepGroup(:,1), num2cell(spatPrepGroupZacc)]';
        tempMovGroupZacc = [tempMovGroup(:,1), num2cell(tempMovGroupZacc)]';
        tempPrepGroupZacc = [tempPrepGroup(:,1), num2cell(tempPrepGroupZacc)]';
        
        save('zacc_spatMov_subcortical', 'spatMovGroupZacc'); save('zacc_spatPrep_subcortical', 'spatPrepGroupZacc')
        save('zacc_tempMov_subcortical', 'tempMovGroupZacc'); save('zacc_tempPrep_subcortical', 'tempPrepGroupZacc')
        
        xlswrite('zacc_spatMov_subcortical', spatMovGroupZacc); xlswrite('zacc_spatPrep_subcortical', spatPrepGroupZacc)
        xlswrite('zacc_tempMov_subcortical', tempMovGroupZacc); xlswrite('zacc_tempPrep_subcortical', tempPrepGroupZacc)
        
    case 'pcm_sub_make_nii' %SUBCORTICAL: unzips aseg file ready for parcellation
        
        sn = varargin{1}; %requires recon-all to be completed through freesurfer for each participant, and for 'aseg' file to be moved to relevant directory
        
        %%Anatomical:
        try
            source = fullfile(subcorticalPCMDir, subj_name{sn}, [subj_name{sn} '_' 'aseg.nii.gz']);
            dest = fullfile(subcorticalPCMDir, subj_name{sn});
            
            gunzip(source,dest); %unzip
            
            disp('segmentation unzip done')
        catch
            disp('No aseg file found. Most likely a typo in file name or missing destination directory!');
        end;
    case 'pcm_sub_make_structs' %extracts each subcortical structure from aseg file, and creates respective nii files
        
        sn = varargin{1};
        
        subcortValues = [10, 11, 12, 13, 16, 17, 18, 26, 28, 30, 31, 49, 50, 51, 52, 53, 54, 58, 60, 87, 63];
        
        for i=1:length(allSubcortStructs)
            
            cd([subcorticalPCMDir, '/', subj_name{sn}])
            
            matlabbatch{1}.spm.util.imcalc.input = {[subcorticalPCMDir, '/' subj_name{sn} '/' subj_name{sn}, '_aseg.nii,1']};
            matlabbatch{1}.spm.util.imcalc.output = [subj_name{sn}, '_', allSubcortStructs{i}];
            matlabbatch{1}.spm.util.imcalc.expression = ['i1 == ', num2str(subcortValues(i))];
            matlabbatch{1}.spm.util.imcalc.var = struct('name', {}, 'value', {});
            matlabbatch{1}.spm.util.imcalc.options.dmtx = 0;
            matlabbatch{1}.spm.util.imcalc.options.mask = 0;
            matlabbatch{1}.spm.util.imcalc.options.interp = 1;
            matlabbatch{1}.spm.util.imcalc.options.dtype = 4;
            
            spm_jobman('run',matlabbatch);
        end
    case 'pcm_sub_reslice' %reslices subcortical niftis into functional scan resolution
        
        sn = varargin{1};
        
        refImageDir = [glmDir, '/', subj_name{sn}]; %directories for functional reference image (beta 1)
        subcortImageDir = [subcorticalPCMDir, '/', subj_name{sn}]; %and for subcortical images
        
        for r=1:length(subcortStructs) %loop through subcortical regions and reslice them to beta image resolution
            
            matlabbatch{1}.spm.spatial.realign.write.data = {[refImageDir, '/beta_0001.nii']; [subcortImageDir, '/', subj_name{sn}, '_', subcortStructs{r}, '.nii']};
            matlabbatch{1}.spm.spatial.realign.write.roptions.which = [2 1];
            matlabbatch{1}.spm.spatial.realign.write.roptions.interp = 4;
            matlabbatch{1}.spm.spatial.realign.write.roptions.wrap = [0 0 0];
            matlabbatch{1}.spm.spatial.realign.write.roptions.mask = 1;
            matlabbatch{1}.spm.spatial.realign.write.roptions.prefix = 'r';
            
            spm_jobman('run',matlabbatch);
            disp([subcortStructs{r} ' resliced'])
        end
    case 'pcm_sub_make_mask'  %makes restricted subcortical analysis mask for MVA
        
        s=varargin{1};
        
        for i=1:length(subcortStructs);
            funMask=fullfile(glmDir, subj_name{s},'maskbrain.nii');
            omask=fullfile(subcorticalPCMDir, subj_name{s},['mr' subj_name{s} '_' subcortStructs{i} '.nii']); %output mask to be used in the future
            subcort = fullfile(subcorticalPCMDir, subj_name{s},['r' subj_name{s} '_' subcortStructs{i} '.nii']);
            
            spm_imcalc({funMask,subcort},omask,'i1 >0.01 & i2 > 0.1',{}); %recorded activity in brain (grey + white matter)
        end
    case 'pcm_sub_makeROIs' %uses region toolbox to define R struct for analysis
        
        s=varargin{1};
        R=cell(length(subcortStructs), 1);
        cd(fullfile(subcorticalPCMDir, subj_name{s}))
        
        for i=1:length(subcortStructs)%for each subcort region
            R{i} = region('roi_image',[subj_name{s} '_' subcortStructs{i} '.nii'],1,subcortStructs{i}); %'mr'
            R{i}.name = [subj_name{s} '_' subcortStructs{i}]; %use toolbox to define, then add name
        end%for each subcort region
        
        R = region_calcregions(R, 'voxelspace', fullfile(glmDir, subj_name{s}, 'beta_0001.nii'));
        
        out = [roiSubDir '/' subj_name{s} '_subcortical_roi'];
        save(strjoin(out,''), 'R'); %save as participant file which holds all regions
    case 'pcm_sub_preWhiten' %pre-whiten data from subcortical ROIs ready for PCM
        
        T = []; %s=varargin{1};
        
        for s=anaSubj
            fprintf('%d.',s); fprintf('/n')
            load([glmDir, '/', subj_name{s}, '/', 'SPM.mat'])
            load([roiSubDir, '/', subj_name{s}, '_subcortical_roi.mat'])
            
            V = SPM.xY.VY;
            for r=1:length(R)
                Y = region_getdata(V,R{r});
                
                [betaW,resMS,~,beta] = rsa.spm.noiseNormalizeBeta(Y,SPM);
                
                S.betaW = {betaW};
                S.betaUW = {bsxfun(@rdivide,beta,sqrt(resMS))};
                S.betaRAW = {beta};
                S.resMS = {resMS};
                S.SN = s;
                S.region = r;
                
                T = addstruct(T,S);
                fprintf('%d.',r)
            end
            fprintf('/n');
        end
        
        save(fullfile(roiSubDir, 'preWhitened_betas.mat'),'-struct','T');
    case 'pcm_sub_genModels' %%%%%%%%%%%%%%%%%% Beginning of PCM analysis %%%%%%%%%%%%%%%%%%
        
        prepProdSimu_genmodels('ordPrep')
        prepProdSimu_genmodels('ordProd')
        prepProdSimu_genmodels('ordSwitch')
        
        prepProdSimu_genmodels('tempPrep')
        prepProdSimu_genmodels('tempProd')
        prepProdSimu_genmodels('tempSwitch')
        
        prepProdSimu_genmodels('intPrep')
        prepProdSimu_genmodels('intProd')
        prepProdSimu_genmodels('intSwitch')
    case 'pcm_sub_fitModels_Prep' %PCM during prep phase only (4 conditions)
        
        modelDir = [modelDir '/onePhase']; %we want models with one phase only
        
        %load representational models
        cd(modelDir)
        files = dir('*.mat');
        for i=1:length(files)
            load(files(i).name)
            models.(D.modelName) = D;
        end
        clear('D')
        
        %load subcortical data for analysis
        W = load(fullfile(roiSubDir, 'preWhitened_betas.mat'));
        
        %define condition variables
        runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
        prep      =[0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0];
        prep=[repmat(prep,1,length(run)) runBSL];
        
        c=repmat(1:4,1,length(run))'; % extract conditions (leave out errors!)
        runc=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]'; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
        
        timingModel.G = pcm_estGCrossval(models.temp.data,runc,c);
        orderModel.G = pcm_estGCrossval(models.ord.data,runc,c);
        integratedModel.G = pcm_estGCrossval(models.int.data,runc,c);
        
        [~,col] = find(prep>0); %identify relevant beta files and assign to pselect
        
        for r=1:length(subcortStructs)
            
            loopCounter = 1;
            for i=anaSubj
                %YTemp = W.betaUW{W.SN == i & W.region == r}; %univariate prewhiten
                YTemp = W.betaW{W.SN == i & W.region == r}; %multivariate prewhiten
                Y{:,loopCounter} = YTemp(col, :);
                loopCounter = loopCounter + 1;
            end
            
            for i=1:length(Y)
                G_hat(:,:,i)=pcm_estGCrossval(Y{:,i},runc,c);
            end
            
            Gm = mean(G_hat,3); % Mean estimate
            
            figure
            subplot(2,4,1);
            H = eye(4)-ones(4)/4;
            imagesc(H*Gm*H');
            title('Empirical Data')
            
            labels = {'O1T1', 'O1T2', 'O2T1', 'O2T2'};
            C= pcm_indicatorMatrix('allpairs',(1:4)');
            [COORD,~]=pcm_classicalMDS(Gm);
            subplot(2,4,2);
            plot(COORD(:,1),COORD(:,2),'o');
            text(COORD(:,1),COORD(:,2),labels ,'VerticalAlignment','bottom','HorizontalAlignment','center')
            % axis equal;
            
            % visualise models
            subplot(2,4,5);
            imagesc(orderModel.G);
            title('Order control')
            
            subplot(2,4,6);
            imagesc(timingModel.G);
            title('Timing control')
            
            subplot(2,4,7);
            imagesc(integratedModel.G);
            title('Integrated control')
            
            % ----------------------------------------------------------------
            % Now build the models
            % Model 1: Null model for baseline: here we use a model which has all finger
            % Patterns be independent - i.e. all finger pairs are equally far away from
            % each other
            %             M{1}.type       = 'component';
            %             M{1}.numGparams = 1;
            %             M{1}.Gc         = zeros(4);
            %             M{1}.name       = 'null';
            
            % Model 2: Order model, derived from simulations with
            % high order decoding
            M{1}.type       = 'component';
            M{1}.numGparams = 1;
            M{1}.Gc         = orderModel.G;
            M{1}.name       = 'O';
            
            % Model 3: Timing model, derived from simulations with
            % high timing decoding
            M{2}.type       = 'component';
            M{2}.numGparams = 1;
            M{2}.Gc         = timingModel.G;
            M{2}.name       = 'T';
            
            % Model 4: Integrated model, derived from simulations with
            % high integrated decoding
            M{3}.type       = 'component';
            M{3}.numGparams = 1;
            M{3}.Gc         = integratedModel.G;
            M{3}.name       = 'I';
            
            %generate combination models
            M = pcm_constructModelFamily(M);
            
            % Model end: Free model as Noise ceiling
            %M{end+1}.type       = 'freechol';
            M{end+1}.type     = 'freedirect';
            M{end}.numCond    = 4;
            M{end}.name       = 'noiseceiling';
            M{end}            = pcm_prepFreeModel(M{end});
            
            runEffect  = 'fixed';
            
            % Fit the models on the group level
            [Tgroup,theta] = pcm_fitModelGroup(Y,M,runc,c,'runEffect',runEffect,'fitScale',1);
            
            % Fit the models through cross-subject crossvalidation
            [Tcross,thetaCr] = pcm_fitModelGroupCrossval(Y,M,runc,c,'runEffect',runEffect,'groupFit',theta,'fitScale',1);
            
            % Provide a plot of the crossvalidated likelihoods
            subplot(2,4,[4 8]);
            T = pcm_plotModelLikelihood_RY(Tcross,M,'upperceil',Tgroup.likelihood(:,length(M)));
            title(['Preparation in ' subcortStructs{r}])
            
            T.region = ones(length(T.likelihood),1)*r;
            T.phase = ones(length(T.likelihood),1)*1; %1 = prep, 2 = prod
            
            save([pcmDir '/data/subcortical/' subcortStructs{r} '_prepPCM.mat'],'Tgroup', 'Tcross', 'T', 'M', 'Gm', 'C')
            clear('M')
        end
    case 'pcm_sub_fitModels_Prod' %PCM during prep phase only (4 conditions)
        
        modelDir = [modelDir '/onePhase']; %we want models with one phase only
        
        %load representational models
        cd(modelDir)
        files = dir('*.mat');
        for i=1:length(files)
            load(files(i).name)
            models.(D.modelName) = D;
        end
        clear('D')
        
        %load subcortical data for analysis
        W = load(fullfile(roiSubDir, 'preWhitened_betas.mat'));
        
        %define condition variables
        runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
        prod      =[1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0];
        prod=[repmat(prod,1,length(run)) runBSL];
        
        c=repmat(1:4,1,length(run))'; % extract conditions (leave out errors!)
        runc=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]'; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
        
        timingModel.G = pcm_estGCrossval(models.temp.data,runc,c);
        orderModel.G = pcm_estGCrossval(models.ord.data,runc,c);
        integratedModel.G = pcm_estGCrossval(models.int.data,runc,c);
        
        [~,col] = find(prod>0); %identify relevant beta files and assign to pselect
        
        for r=1:length(subcortStructs)
            
            loopCounter = 1;
            for i=anaSubj
                %YTemp = W.betaUW{W.SN == i & W.region == r}; %univariate prewhiten
                YTemp = W.betaW{W.SN == i & W.region == r}; %multivariate prewhiten
                Y{:,loopCounter} = YTemp(col, :);
                loopCounter = loopCounter + 1;
            end
            
            for i=1:length(Y)
                G_hat(:,:,i)=pcm_estGCrossval(Y{:,i},runc,c);
            end
            
            Gm = mean(G_hat,3); % Mean estimate
            
            figure
            subplot(2,4,1);
            H = eye(4)-ones(4)/4;
            imagesc(H*Gm*H');
            title('Empirical Data')
            
            %             C= pcm_indicatorMatrix('allpairs',[1:4]');
            %             [COORD,l]=pcm_classicalMDS(Gm,'contrast',C);
            %             subplot(2,4,2);
            %             plot(COORD(:,1),COORD(:,2),'o');
            %             axis equal;
            
            labels = {'O1T1', 'O1T2', 'O2T1', 'O2T2'};
            C= pcm_indicatorMatrix('allpairs',(1:4)');
            [COORD,~]=pcm_classicalMDS(Gm);
            subplot(2,4,2);
            plot(COORD(:,1),COORD(:,2),'o');
            text(COORD(:,1),COORD(:,2),labels ,'VerticalAlignment','bottom','HorizontalAlignment','center')
            % axis equal;
            
            % visualise models
            subplot(2,4,5);
            imagesc(orderModel.G);
            title('Order control')
            
            subplot(2,4,6);
            imagesc(timingModel.G);
            title('Timing control')
            
            subplot(2,4,7);
            imagesc(integratedModel.G);
            title('Integrated control')
            
            % ----------------------------------------------------------------
            % Now build the models
            % Model 1: Null model for baseline: here we use a model which has all finger
            % Patterns be independent - i.e. all finger pairs are equally far away from
            % each other
            %             M{1}.type       = 'component';
            %             M{1}.numGparams = 1;
            %             M{1}.Gc         = zeros(4);
            %             M{1}.name       = 'null';
            
            % Model 2: Order model, derived from simulations with
            % high order decoding
            M{1}.type       = 'component';
            M{1}.numGparams = 1;
            M{1}.Gc         = orderModel.G;
            M{1}.name       = 'O';
            
            % Model 3: Timing model, derived from simulations with
            % high timing decoding
            M{2}.type       = 'component';
            M{2}.numGparams = 1;
            M{2}.Gc         = timingModel.G;
            M{2}.name       = 'T';
            
            % Model 4: Integrated model, derived from simulations with
            % high integrated decoding
            M{3}.type       = 'component';
            M{3}.numGparams = 1;
            M{3}.Gc         = integratedModel.G;
            M{3}.name       = 'I';
            
            %generate combination models
            M = pcm_constructModelFamily(M);
            
            % Model end: Free model as Noise ceiling
            %M{end+1}.type       = 'freechol';
            M{end+1}.type     = 'freedirect';
            M{end}.numCond    = 4;
            M{end}.name       = 'noiseceiling';
            M{end}            = pcm_prepFreeModel(M{end});
            
            runEffect  = 'fixed';
            
            % Fit the models on the group level
            [Tgroup,theta] = pcm_fitModelGroup(Y,M,runc,c,'runEffect',runEffect,'fitScale',1);
            
            % Fit the models through cross-subject crossvalidation
            [Tcross,thetaCr] = pcm_fitModelGroupCrossval(Y,M,runc,c,'runEffect',runEffect,'groupFit',theta,'fitScale',1);
            
            % Provide a plot of the crossvalidated likelihoods
            subplot(2,4,[4 8]);
            T = pcm_plotModelLikelihood_RY(Tcross,M,'upperceil',Tgroup.likelihood(:,length(M)));
            title(['Production in ' subcortStructs{r}])
            
            T.region = ones(length(T.likelihood),1)*r;
            T.phase = ones(length(T.likelihood),1)*2; %1 = prep, 2 = prod
            
            save([pcmDir '/data/subcortical/' subcortStructs{r} '_prodPCM.mat'],'Tgroup', 'Tcross', 'T', 'M', 'Gm', 'C')
            clear('M')
        end
    case 'pcm_sub_yokoi_prep'
        
        modelDir = [modelDir '/onePhase']; %we want models with one phase only
        R=[]; p=[];
        
        %load representational models
        cd(modelDir)
        files = dir('*.mat');
        for i=1:length(files)
            load(files(i).name)
            models.(D.modelName) = D;
        end
        clear('D')
        
        %load subcortical data for analysis
        W = load(fullfile(roiSubDir, 'preWhitened_betas.mat'));
        
        %define condition variables
        runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
        prep      =[0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0];
        prep=[repmat(prep,1,length(run)) runBSL];
        
        condc=repmat(1:4,1,length(run))'; % extract conditions (leave out errors!)
        runc=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]'; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
        
        timingModel.G = pcm_estGCrossval(models.temp.data,runc,condc);
        orderModel.G = pcm_estGCrossval(models.ord.data,runc,condc);
        integratedModel.G = pcm_estGCrossval(models.int.data,runc,condc);
        
        [~,col] = find(prep>0); %identify relevant beta files and assign to pselect
        
        % ----------------------------------------------------------------
        % Now build the models
        % Model 1: Null model for baseline: here we use a model which has all finger
        % Patterns be independent - i.e. all finger pairs are equally far away from
        % each other
        %             M{1}.type       = 'component';
        %             M{1}.numGparams = 1;
        %             M{1}.Gc         = zeros(4);
        %             M{1}.name       = 'null';
        
        % Model 2: Order model, derived from simulations with
        % high order decoding
        M{1}.type       = 'component';
        M{1}.numGparams = 1;
        M{1}.Gc         = orderModel.G;
        M{1}.name       = 'O';
        
        % Model 3: Timing model, derived from simulations with
        % high timing decoding
        M{2}.type       = 'component';
        M{2}.numGparams = 1;
        M{2}.Gc         = timingModel.G;
        M{2}.name       = 'T';
        
        % Model 4: Integrated model, derived from simulations with
        % high integrated decoding
        M{3}.type       = 'component';
        M{3}.numGparams = 1;
        M{3}.Gc         = integratedModel.G;
        M{3}.name       = 'I';
        
        %generate combination models
        [M, CompIdx] = pcm_constructModelFamily(M);
        
        %             % Model end: Free model as Noise ceiling
        %             %M{end+1}.type       = 'freechol';
        %             M{end+1}.type     = 'freedirect';
        %             M{end}.numCond    = 4;
        %             M{end}.name       = 'noiseceiling';
        %             M{end}            = pcm_prepFreeModel(M{end});
        
        runEffect  = 'fixed';
        
        
        for r=1:length(subcortStructs)
            
            loopCounter = 1;
            for i=anaSubj
                %YTemp = W.betaUW{W.SN == i & W.region == r}; %univariate prewhiten
                YTemp = W.betaW{W.SN == i & W.region == r}; %multivariate prewhiten
                Y{:,loopCounter} = YTemp(col, :);
                loopCounter = loopCounter + 1;
            end
            
            for i=1:length(Y)
                G_hat(:,:,i)=pcm_estGCrossval(Y{:,i},runc,condc);
            end
            
            Gm = mean(G_hat,3); % Mean estimate
            
            figure
            subplot(2,4,1);
            H = eye(4)-ones(4)/4;
            imagesc(H*Gm*H');
            title('Empirical Data')
            
            labels = {'O1T1', 'O1T2', 'O2T1', 'O2T2'};
            C= pcm_indicatorMatrix('allpairs',(1:4)');
            [COORD,~]=pcm_classicalMDS(Gm);
            subplot(2,4,2);
            plot(COORD(:,1),COORD(:,2),'o');
            text(COORD(:,1),COORD(:,2),labels ,'VerticalAlignment','bottom','HorizontalAlignment','center')
            % axis equal;
            
            % visualise models
            subplot(2,4,5);
            imagesc(orderModel.G);
            title('Order control')
            
            subplot(2,4,6);
            imagesc(timingModel.G);
            title('Timing control')
            
            subplot(2,4,7);
            imagesc(integratedModel.G);
            title('Integrated control')
            
            %%% Yokoi script %%%
            [T,Tcv,theta_cv] = runPCM(Y, condc, runc, M);
            
            % calculate normal logBF
            logBF = bsxfun(@minus, Tcv.likelihood, Tcv.likelihood(:,1));
            noiseceiling = logBF(:,end);
            logBF = logBF(:,1:end-1);
            
            % calculate component logBF
            [PP, logBFc] = pcm_componentPosterior(logBF, CompIdx);
            
            % get PXP (spm_BMS) for logBFc
            for c=1:3
                lme = [logBFc(:,c), zeros(size(logBFc(:,2)))];
                [~,~,~,pxp_] = spm_BMS (lme);
                pxp(:,c) = repmat(pxp_(1), size(lme,1),1);
            end
            
            % get PXP for noise-ceiling logBF (vs null)
            lme = [noiseceiling, zeros(size(noiseceiling))];
            [~,~,~,pxp_] = spm_BMS (lme);
            pxp_ceiling(:,1) = repmat(pxp_(1), size(lme,1),1);
            
            % concatenate results
            p.logBF = logBF;
            p.noiseceiling = noiseceiling;
            p.pxp_ceiling = pxp_ceiling;
            p.logBFc = logBFc;
            p.pxp = pxp;
            p.region = repmat(r,length(pxp),1);
            p.phase = ones(length(pxp),1);
            %             p.sn = repmat(s, length(pxp),1);
            %             p.hemis = repmat(h, length(pxp),1);
            %             p.patch = repmat(p, length(pxp),1);
            %             p.nodeID = repmat(D.nodeID(1), length(pxp),1);
            R = addstruct(R,p);
            
        end
        
        save([pcmDir '/data/subcortical/prepPCM_yokoi.mat'],'R')
        cd(fullfile(pcmDir, 'data'))
    case 'pcm_sub_yokoi_prod'
        
        modelDir = [modelDir '/onePhase']; %we want models with one phase only
        R=[]; p=[];
        
        %load representational models
        cd(modelDir)
        files = dir('*.mat');
        for i=1:length(files)
            load(files(i).name)
            models.(D.modelName) = D;
        end
        clear('D')
        
        %load subcortical data for analysis
        W = load(fullfile(roiSubDir, 'preWhitened_betas.mat'));
        
        %define condition variables
        runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
        prod      =[1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0];
        prod=[repmat(prod,1,length(run)) runBSL];
        
        condc=repmat(1:4,1,length(run))'; % extract conditions (leave out errors!)
        runc=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]'; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
        
        timingModel.G = pcm_estGCrossval(models.temp.data,runc,condc);
        orderModel.G = pcm_estGCrossval(models.ord.data,runc,condc);
        integratedModel.G = pcm_estGCrossval(models.int.data,runc,condc);
        
        [~,col] = find(prod>0); %identify relevant beta files and assign to pselect
        
        % ----------------------------------------------------------------
        % Now build the models
        % Model 1: Null model for baseline: here we use a model which has all finger
        % Patterns be independent - i.e. all finger pairs are equally far away from
        % each other
        %             M{1}.type       = 'component';
        %             M{1}.numGparams = 1;
        %             M{1}.Gc         = zeros(4);
        %             M{1}.name       = 'null';
        
        % Model 2: Order model, derived from simulations with
        % high order decoding
        M{1}.type       = 'component';
        M{1}.numGparams = 1;
        M{1}.Gc         = orderModel.G;
        M{1}.name       = 'O';
        
        % Model 3: Timing model, derived from simulations with
        % high timing decoding
        M{2}.type       = 'component';
        M{2}.numGparams = 1;
        M{2}.Gc         = timingModel.G;
        M{2}.name       = 'T';
        
        % Model 4: Integrated model, derived from simulations with
        % high integrated decoding
        M{3}.type       = 'component';
        M{3}.numGparams = 1;
        M{3}.Gc         = integratedModel.G;
        M{3}.name       = 'I';
        
        %generate combination models
        [M, CompIdx] = pcm_constructModelFamily(M);
        
        %             % Model end: Free model as Noise ceiling
        %             %M{end+1}.type       = 'freechol';
        %             M{end+1}.type     = 'freedirect';
        %             M{end}.numCond    = 4;
        %             M{end}.name       = 'noiseceiling';
        %             M{end}            = pcm_prepFreeModel(M{end});
        
        runEffect  = 'fixed';
        
        
        for r=1:length(subcortStructs)
            
            loopCounter = 1;
            for i=anaSubj
                %YTemp = W.betaUW{W.SN == i & W.region == r}; %univariate prewhiten
                YTemp = W.betaW{W.SN == i & W.region == r}; %multivariate prewhiten
                Y{:,loopCounter} = YTemp(col, :);
                loopCounter = loopCounter + 1;
            end
            
            for i=1:length(Y)
                G_hat(:,:,i)=pcm_estGCrossval(Y{:,i},runc,condc);
            end
            
            Gm = mean(G_hat,3); % Mean estimate
            
            figure
            subplot(2,4,1);
            H = eye(4)-ones(4)/4;
            imagesc(H*Gm*H');
            title('Empirical Data')
            
            labels = {'O1T1', 'O1T2', 'O2T1', 'O2T2'};
            C= pcm_indicatorMatrix('allpairs',(1:4)');
            [COORD,~]=pcm_classicalMDS(Gm);
            subplot(2,4,2);
            plot(COORD(:,1),COORD(:,2),'o');
            text(COORD(:,1),COORD(:,2),labels ,'VerticalAlignment','bottom','HorizontalAlignment','center')
            % axis equal;
            
            % visualise models
            subplot(2,4,5);
            imagesc(orderModel.G);
            title('Order control')
            
            subplot(2,4,6);
            imagesc(timingModel.G);
            title('Timing control')
            
            subplot(2,4,7);
            imagesc(integratedModel.G);
            title('Integrated control')
            
            %%% Yokoi script %%%
            [T,Tcv,theta_cv] = runPCM(Y, condc, runc, M);
            
            % calculate normal logBF
            logBF = bsxfun(@minus, Tcv.likelihood, Tcv.likelihood(:,1));
            noiseceiling = logBF(:,end);
            logBF = logBF(:,1:end-1);
            
            % calculate component logBF
            [PP, logBFc] = pcm_componentPosterior(logBF, CompIdx);
            
            % get PXP (spm_BMS) for logBFc
            for c=1:3
                lme = [logBFc(:,c), zeros(size(logBFc(:,2)))];
                [~,~,~,pxp_] = spm_BMS (lme);
                pxp(:,c) = repmat(pxp_(1), size(lme,1),1);
            end
            
            % get PXP for noise-ceiling logBF (vs null)
            lme = [noiseceiling, zeros(size(noiseceiling))];
            [~,~,~,pxp_] = spm_BMS (lme);
            pxp_ceiling(:,1) = repmat(pxp_(1), size(lme,1),1);
            
            % concatenate results
            p.logBF = logBF;
            p.noiseceiling = noiseceiling;
            p.pxp_ceiling = pxp_ceiling;
            p.logBFc = logBFc;
            p.pxp = pxp;
            p.region = repmat(r,length(pxp),1);
            p.phase = repmat(2,length(pxp),1);
            %             p.sn = repmat(s, length(pxp),1);
            %             p.hemis = repmat(h, length(pxp),1);
            %             p.patch = repmat(p, length(pxp),1);
            %             p.nodeID = repmat(D.nodeID(1), length(pxp),1);
            R = addstruct(R,p);
            
        end
        
        save([pcmDir '/data/subcortical/prodPCM_yokoi.mat'],'R')
        cd(fullfile(pcmDir, 'data'))
    case 'pcm_sub_displayResults'
        
        load(fullfile(pcmDir, 'data', 'subcortical', 'prepPCM_yokoi.mat'), 'R')
        R.phase = ones(length(R.region), 1); %1 for prep
        
        P = R; R=[];
        
        load(fullfile(pcmDir, 'data', 'subcortical', 'prodPCM_yokoi.mat'), 'R')
        R.phase = ones(length(R.region), 1) * 2; %2 for prod
        
        P = addstruct(P, R);
        
        figure
        barplot([P.phase, P.region], P.logBFc, 'facecolor', {[0 0 1], [1 0 0], [0 1 0]})
        drawline(1, 'dir', 'horz')
        xlabel('Region')
        ylabel('Log BF (relative to noise ceiling)')
        
        figure
        barplot([P.phase, P.region], P.pxp, 'facecolor', {[0 0 1], [1 0 0], [0 1 0]})
        drawline(0.75, 'dir', 'horz')
        xlabel('Region')
        ylabel('Protected exceedance probability (PXP)')
    case 'pcm_sub_fitModels_PrepxProd' %PCM script - fits models to data (4 sequences x prepProd)
        
        models = prepProdSimu_loadModels(modelDir);
        
        %         anaSubj = [3, 5, 6, 7, 9];
        
        for r=1:length(subcortStructs)
            %         for r=6;
            
            disp(['analysing ' subcortStructs{r}])
            
            %load subcortical data for analysis
            loopCounter = 1;
            for s=anaSubj
                
                cd(fullfile(glmDir, subj_name{s})); %load SPM data
                load SPM;
                nrruns=length(SPM.nscan);
                
                runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
                prep      =[0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0];
                prep=[repmat(prep,1,nrruns) runBSL];
                
                prod      =[1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0];
                prod=[repmat(prod,1,nrruns) runBSL];
                
                c=repmat(1:8,1,nrruns)'; % extract conditions (leave out errors!)
                run=[1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6]'; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
                
                [M, R] = prepProdSimu_prepModels(models,run,c);
                
                [~,prepCol] = find(prep>0); prepCol = reshape(prepCol,4,[]);
                [~,prodCol] = find(prod>0); prodCol = reshape(prodCol,4,[]);
                col = [prepCol; prodCol]; col = reshape(col,1,[]);
                
                
                P={SPM.Vbeta(1:126).fname}';
                Pselect=[];
                for i=1:length(col)
                    Pselect{i,1}= P{col(i)};
                end
                
                S = load(fullfile(subcorticalAreaDir,subj_name{s},[subj_name{s} '_decodeArea_' subcortStructs{r} '.mat']));
                Vin = spm_vol(char(Pselect));
                
                %extract voxels in decoding area from beta files and pass to MVPA function
                linVox=unique(cat(2,S.LI{:})');
                [I,J,K]=ind2sub(Vin(1).dim,linVox);
                X = zeros(length(linVox),length(Vin));
                
                for i=1:length(Vin) %this gives us a voxelN x betaN matrix
                    X(:,i)=spm_sample_vol(Vin(i),double(I),double(J),double(K),0);
                end
                
                [nanidx, ~] = find(isnan(X)); %remove nan values contained in beta image due to signal loss(?)
                nanidx = unique(nanidx);
                X(nanidx,:) = [];
                Y{:,loopCounter}=X';
                
                loopCounter = loopCounter+1;
            end%subj loop
            
            for i=1:length(Y)
                G_hat(:,:,i)=pcm_estGCrossval(Y{:,i},run,c);
            end;
            
            Gm = mean(G_hat,3); % Mean estimate
            
            figure
            subplot(3,7,[1, 8]);
            H = eye(8)-ones(8)/8;
            imagesc(H*Gm*H');
            title('Empirical Data')
            
            C= pcm_indicatorMatrix('allpairs',[1:8]');
            [COORD,l]=pcm_classicalMDS(Gm,'contrast',C);
            subplot(3,7,15);
            plot(COORD(:,1),COORD(:,2),'o');
            axis equal;
            
            % visualise models
            subplot(3,7,2);
            imagesc(R.orderPrepModel.G);
            title('Order Prep')
            
            subplot(3,7,9);
            imagesc(R.orderProdModel.G);
            title('Order Prod')
            
            subplot(3,7,16);
            imagesc(R.orderMaintModel.G);
            title('Order Maint')
            
            subplot(3,7,3);
            imagesc(R.timingPrepModel.G);
            title('Timing Prep')
            
            subplot(3,7,10);
            imagesc(R.timingProdModel.G);
            title('Timing Prod')
            
            subplot(3,7,17);
            imagesc(R.timingMaintModel.G);
            title('Timing Maint')
            
            subplot(3,7,4);
            imagesc(R.integratedPrepModel.G);
            title('Integrated Prep')
            
            subplot(3,7,11);
            imagesc(R.integratedProdModel.G);
            title('Integrated Prod')
            
            subplot(3,7,18);
            imagesc(R.integratedMaintModel.G);
            title('Integrated Maint')
            
            % Treat the run effect as random or fixed?
            % We are using a fixed run effect here, as we are not interested in the
            % activity relative the the baseline (rest) - so as in RSA, we simply
            % subtract out the mean patttern across all conditions.
            runEffect  = 'fixed';
            
            % Fit the models on the group level
            [Tgroup,theta] = pcm_fitModelGroup(Y,M,run,c,'runEffect',runEffect,'fitScale',1);
            
            % Fit the models through cross-subject crossvalidation
            [Tcross,thetaCr] = pcm_fitModelGroupCrossval(Y,M,run,c,'runEffect',runEffect,'groupFit',theta,'fitScale',1);
            
            % Provide a plot of the crossvalidated likelihoods
            subplot(3,7,[5 6 7 12 13 14 19 20 21]);
            T = pcm_plotModelLikelihood_RY(Tcross,M,'upperceil',Tgroup.likelihood(:,length(M)));
            title(subcortStructs{r})
            
        end
    case 'pcm_sub_plotGroup'
        
        phase = {'Preparation', 'Production'};
        updatedOrder = [1 2 7 8 5 6 9 10 3 4 11 12 17 18 15 16 19 20 13 14]; %order regions to be nicer to visualise when plotted
        loopCounter = 1;
        
        %load prep and prod for all regions
        pcmDataDir = [pcmDir '/data/subcortical']; %PCM data directory
        cd(pcmDataDir)
        files = dir('*.mat');
        for i=updatedOrder%load data from ROIs into struct
            Y = load(files(i).name);
            R(loopCounter) = Y;
            loopCounter = loopCounter + 1;
        end
        
        subcortStructs = regexprep(subcortStructs, '_',' '); %change underscores to spaces in title names
        
        figure
        for i=1:length(R)/2
            subplot(5,2,i)
            pcm_plotModelLikelihood_RY(R(i).Tcross,R(i).M,'upperceil',R(i).Tgroup.likelihood(:,length(R(i).M)));
            title([phase{unique(R(i).T.phase)} ' in ' subcortStructs{unique(R(i).T.region)}])
        end
        
        figure
        for i=11:length(R)
            subplot(5,2,i-10)
            pcm_plotModelLikelihood_RY(R(i).Tcross,R(i).M,'upperceil',R(i).Tgroup.likelihood(:,length(R(i).M)));
            title([phase{unique(R(i).T.phase)} ' in ' subcortStructs{unique(R(i).T.region)}])
        end
        
        figure
        for i=1:length(R)/2
            labels = {'O1T1', 'O1T2', 'O2T1', 'O2T2'};
            C= pcm_indicatorMatrix('allpairs',(1:4)');
            [COORD,l]=pcm_classicalMDS(R(i).Gm);
            subplot(5,2,i);
            plot(COORD(:,1),COORD(:,2),'o');
            text(COORD(:,1),COORD(:,2),labels ,'VerticalAlignment','bottom','HorizontalAlignment','center')
            % axis equal;
            title([phase{unique(R(i).T.phase)} ' in ' subcortStructs{unique(R(i).T.region)}])
        end
        
        figure
        for i=11:length(R)
            labels = {'O1T1', 'O1T2', 'O2T1', 'O2T2'};
            C= pcm_indicatorMatrix('allpairs',(1:4)');
            [COORD,l]=pcm_classicalMDS(R(i).Gm);
            subplot(5,2,i-10);
            plot(COORD(:,1),COORD(:,2),'o');
            text(COORD(:,1),COORD(:,2),labels ,'VerticalAlignment','bottom','HorizontalAlignment','center')
            % axis equal;
            title([phase{unique(R(i).T.phase)} ' in ' subcortStructs{unique(R(i).T.region)}])
        end
    case 'pcm_sub_BGPlot'
        
        phase = {'Preparation', 'Production'};
        updatedOrder = [1 2 7 8]; %order regions to be nicer to visualise when plotted
        loopCounter = 1;
        
        %load prep and prod for all regions
        pcmDataDir = [pcmDir '/data/subcortical']; %PCM data directory
        cd(pcmDataDir)
        files = dir('*.mat');
        for i=updatedOrder%load data from ROIs into struct
            Y = load(files(i).name);
            R(loopCounter) = Y;
            loopCounter = loopCounter + 1;
        end
        
        subcortStructs = regexprep(subcortStructs, '_',' '); %change underscores to spaces in title names
        
        for i=1:length(R)
            R(i).Tcross.iterations(:,5:end-1) = [];
            R(i).Tcross.time(:,5:end-1) = [];
            R(i).Tcross.fitLike(:,5:end-1) = [];
            R(i).Tcross.reg(:,5:end-1) = [];
            R(i).Tcross.likelihood(:,5:end-1) = [];
            R(i).Tcross.noise(:,5:end-1) = [];
            R(i).Tcross.scale(:,5:end-1) = [];
        end
        
        for i=1:length(R)
            R(i).Tgroup.iterations(:,5:end-1) = [];
            R(i).Tgroup.time(:,5:end-1) = [];
            R(i).Tgroup.noise(:,5:end-1) = [];
            R(i).Tgroup.scale(:,5:end-1) = [];
            R(i).Tgroup.likelihood(:,5:end-1) = [];
        end
        
        for i=1:length(R)
            R(i).M(5:8) = [];
        end
        
        
        figure
        for i=1:length(R)
            subplot(2,2,i)
            pcm_plotModelLikelihood_RY(R(i).Tcross,R(i).M,'upperceil',R(i).Tgroup.likelihood(:,length(R(i).M)));
            title([phase{unique(R(i).T.phase)} ' in ' subcortStructs{unique(R(i).T.region)}])
            ylim([0, 2.2])
        end
        
        figure
        for i=1:length(R)
            labels = {'O1T1', 'O1T2', 'O2T1', 'O2T2'};
            C= pcm_indicatorMatrix('allpairs',(1:4)');
            %C = [1 0 -1 0];
            [COORD,~]=pcm_classicalMDS(R(i).Gm,'contrast',C);
            subplot(2,2,i);
            plot(COORD(:,1),COORD(:,2),'o');
            text(COORD(:,1),COORD(:,2),labels ,'VerticalAlignment','bottom','HorizontalAlignment','center')
            %axis equal;
            title([phase{unique(R(i).T.phase)} ' in ' subcortStructs{unique(R(i).T.region)}])
            ylim([-0.06, 0.035])
            xlim([-0.05, 0.03])
        end
    case 'pcm_defineSearchLight' % Define the search lights for the PCM analysis
        
        s=varargin{1};
        cd(fullfile(subcorticalPCMDir, subj_name{s}));
        load(fullfile(roiSubDir, [subj_name{s}, '_subcortical_roi.mat']), 'R')
        
        if ~isfolder([pcmDir, '/searchlight'])
            mkdir([pcmDir, '/searchlight'])
        end
        
        radius=16;
        numVox=160;
        
        for r = 1:length(subcortStructs)
            
            V=spm_vol(['mr' subj_name{s} '_' subcortStructs{r} '.nii']); %if preceded by case MVA_mask
            
            [LI,voxmin,voxmax,n]=lmva_voxelselection(R{r,1}.data', R{r,1}.data', [radius numVox], V.mat, V.dim);
            save ([pcmDir, '/searchlight/' subj_name{s} '_' subcortStructs{r} '_' 'volsearch160.mat'], 'vox', 'LI', 'voxmin', 'voxmax', 'n')
            
            cd(fullfile(subcorticalPCMDir, subj_name{s}));
            V=spm_vol(['mr' subj_name{s} '_' subcortStructs{r} '.nii']); %if preceded by case MVA_mask
            X=spm_read_vols(V);
            [i,j,k]=ind2sub(size(X),find(X~=0));
            vox=[i j k];
            %             [LI,voxmin,voxmax,n]=lmva_voxelselection(vox(:,:)',vox',[radius numVox],V.mat,V.dim,[],'mva160_numvox.nii');
        end
    case 'pcm_sub_fitModels_PrepSearchlight'
        
        s=varargin{1};
        
        %%%Model Generation
        modelDir = [modelDir '/onePhase']; %we want models with one phase only
        %load representational models
        cd(modelDir)
        files = dir('*.mat');
        for i=1:length(files)
            load(files(i).name)
            models.(D.modelName) = D;
        end
        clear('D')
        c=repmat(1:4,1,length(run))'; % extract conditions (leave out errors!)
        run=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]'; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
        timingModel.G = pcm_estGCrossval(models.temp.data,run,c);
        orderModel.G = pcm_estGCrossval(models.ord.data,run,c);
        integratedModel.G = pcm_estGCrossval(models.int.data,run,c);
        
        % Model 1: Order model, derived from simulations with
        % high order decoding
        M{1}.type       = 'component';
        M{1}.numGparams = 1;
        M{1}.Gc         = orderModel.G;
        M{1}.name       = 'O';
        
        % Model 2: Timing model, derived from simulations with
        % high timing decoding
        M{2}.type       = 'component';
        M{2}.numGparams = 1;
        M{2}.Gc         = timingModel.G;
        M{2}.name       = 'T';
        
        % Model 3: Integrated model, derived from simulations with
        % high integrated decoding
        M{3}.type       = 'component';
        M{3}.numGparams = 1;
        M{3}.Gc         = integratedModel.G;
        M{3}.name       = 'I';
        
        %generate combination models
        M = pcm_constructModelFamily(M);
        
        % Model end: Free model as Noise ceiling
        % M{end+1}.type       = 'freechol';
        M{end+1}.type     = 'freedirect';
        M{end}.numCond    = 4;
        M{end}.name       = 'noiseceiling';
        M{end}            = pcm_prepFreeModel(M{end});
        
        for r=1:length(subcortStructs);
            
            cd(fullfile(glmDir, subj_name{s}));
            load SPM;
            nrruns=length(SPM.nscan);
            
            runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
            prep      =[0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0];
            prep=[repmat(prep,1,nrruns) runBSL];
            
            [~,col] = find(prep>0); %identify relevant beta files and assign to pselect
            P={SPM.Vbeta(1:126).fname}';
            Pselect=[];
            for i=1:length(col)
                Pselect{i,1}= P{col(i)};
            end
            
            out = {fullfile(pcmDir, 'data', 'subcortical', subj_name{s}, [subj_name{s}, '_' subcortStructs{r} '_PCMLikelihood.nii'])};
            runEffect  = 'fixed';
            
            tstart = tic
            lmva_spm(fullfile(subcorticalSearchDir,subj_name{s},[subj_name{s} '_' subcortStructs{r} '_volsearch160.mat']),Pselect,out,@pcm_searchlight,'params',{M,run,c});
            telapsed = toc(tstart)
        end
        
        
        
        % Fit the models on the group level
        [Tgroup,theta] = pcm_fitModelGroup(Y,M,run,c,'runEffect',runEffect,'fitScale',1);
        
        % Fit the models through cross-subject crossvalidation
        [Tcross,thetaCr] = pcm_fitModelGroupCrossval(Y,M,run,c,'runEffect',runEffect,'groupFit',theta,'fitScale',1);
        
        lmva_spm(fullfile(subcorticalSearchDir,subj_name{s},[subj_name{s} '_' subcortStructs{r} '_volsearch160.mat']),Pselect,out,@combinedclass,'params',{c,run,train,test});
        
    case 'pcm_cb_segment' %%%%%%%%%%%%%%%%%%% BEGINNING OF SUIT ANALYSIS (CEREBELLUM) %%%%%%%%%%%%%%%%%%%%%%%
        %Isolate the cerebellum of each participant - produces 'c_<source>_pcereb' (cerebellar mask) and '<source>_seg1/2' (grey and white matter respectively) images
        
        sn=varargin{1};
        cd([baseDir '/imaging/anatomicals/' subj_name{sn}]);
        disp(['suit_segmenting ' subj_name{sn}])
        
        anatomical = {[subj_name{sn} '_anatomical.nii']};
        
        suit_isolate_seg(anatomical, 'maskp', 0.2) %change maskp for probability value. Higher = tighter mask. Hand-correct using MRIcron if necessary
    case 'pcm_cb_makeMask' %restrict area of analysis to grey matter - produces 'maskbrainSUIT.nii'
        
        s=varargin{1};
        
        if isfolder([baseDir '/imaging/suit/' subj_name{s}]) == 0
            mkdir([baseDir '/imaging/suit/' subj_name{s}])
        end
        
        mask=fullfile(glmDir, subj_name{s},'mask.nii');
        %         suit=fullfile(anatDir, subj_name{s},['c_', subj_name{s},'_anatomical_pcereb.nii']); %pcereb holds all cerebellum-related regions to a value of 1...
        suit=fullfile(anatDir, subj_name{s},[subj_name{s}, '_anatomical_seg1.nii']); %whereas _seg1 is only grey matter and sets extra-cerebellar regions (e.g. pons) to values other than 1...
        omask=fullfile(suitDir, subj_name{s},'maskbrainSUIT.nii');
        
        spm_imcalc_ui({mask,suit},omask,'i1>0 & i2>0.999',{}); %so including a mask of 0.999 makes sure we only include cerebellar regions.
    case 'pcm_cb_make_nii' %%% Cerebellar PCM Analysis %%% Convert input from volbrain into asegCB .nii file, saved in anatomicalDir
        
        %Run CERES segmentation (https://www.volbrain.upv.es/) on zipped T1 scans first.
        %Then download all folders in *native space* to the cerebellum directory.
        %Ref: Manjon & Coupe, 2016: volBrain: An Online MRI Brain Volumetry System
        
        cd([cerebellumDir '/raw']) %cd to CB directory and get all foldernames
        folderName = dir('native_*');
        for i=1:length(folderName)
            filename = dir([folderName(i).name '/native_lab*']);
            anaSubjName = regexp(folderName(i).name,'((?<=native_).*(?=_anatomical))','match'); %extract 's0x' from foldername
            
            if ~isfolder([cerebellumDir '/' anaSubjName{1}])
                mkdir([cerebellumDir '/' anaSubjName{1}])
            end
            
            copyfile([folderName(i).name '/' filename(1).name], [cerebellumDir '/' anaSubjName{1} '/' anaSubjName{1} '_asegCB.nii']) %move and rename file
        end
    case 'pcm_cb_make_structs_suit' %extracts each subcortical structure from aseg file, and creates respective nii files
        
        suitToolDir = [toolDir, '/spm12/toolbox/suit/atlasesSUIT'];
        cd([cerebellumDir '/atlasSUIT'])
        
        for i=1:length(suitCBRegions)
            
            matlabbatch{1}.spm.util.imcalc.input = {[suitToolDir, '/Lobules-SUIT.nii']};
            matlabbatch{1}.spm.util.imcalc.output = [suitCBRegions{2,i}];
            matlabbatch{1}.spm.util.imcalc.expression = ['i1 == ', num2str(suitCBRegions{1,i})];
            matlabbatch{1}.spm.util.imcalc.var = struct('name', {}, 'value', {});
            matlabbatch{1}.spm.util.imcalc.options.dmtx = 0;
            matlabbatch{1}.spm.util.imcalc.options.mask = 0;
            matlabbatch{1}.spm.util.imcalc.options.interp = 1;
            matlabbatch{1}.spm.util.imcalc.options.dtype = 4;
            
            spm_jobman('run',matlabbatch);
        end
    case 'pcm_cb_makeROIs_suit' %CB ANALYSIS - uses region toolbox to define R struct for analysis
        
        s=varargin{1};
        R=cell(length(cbRegions), 1);
        cd(fullfile(cerebellumDir, subj_name{s}))
        
        for i=1:length(cbRegions)%for each subcort region
            R{i} = region('roi_image',[subj_name{s} '_' cbRegions{i} '.nii'],1,cbRegions{i}); %'mr'
            R{i}.name = [subj_name{s} '_' cbRegions{i}]; %use toolbox to define, then add name
        end%for each subcort region
        
        R = region_calcregions(R, 'voxelspace', fullfile(glmDir, subj_name{s}, 'beta_0001.nii'));
        
        out = [roiCbDir '/' subj_name{s} '_cerebellum_roi'];
        save(strjoin(out,''), 'R'); %save as participant file which holds all regions
    case 'pcm_cb_reslice_suit' %reslice cerebellar structures into functional resolution - for voxel selection in later searchlight
        
        sn = varargin{1};
        
        refImageDir = [cerebellumDir, '/', subj_name{sn}]; %directories for functional reference image (beta 1)
        cerebellumImageDir = [cerebellumDir, '/atlasSUIT']; %and for cerebellar images
        
        for r=1:length(suitCBRegions) %loop through cerebellar regions and reslice them to beta image resolution
            
            matlabbatch{1}.spm.spatial.realign.write.data = {[refImageDir, '/beta_0001.nii']; [cerebellumImageDir, '/', suitCBRegions{2,r}, '.nii']};
            matlabbatch{1}.spm.spatial.realign.write.roptions.which = [2 1];
            matlabbatch{1}.spm.spatial.realign.write.roptions.interp = 4;
            matlabbatch{1}.spm.spatial.realign.write.roptions.wrap = [0 0 0];
            matlabbatch{1}.spm.spatial.realign.write.roptions.mask = 1;
            matlabbatch{1}.spm.spatial.realign.write.roptions.prefix = 'r';
            
            spm_jobman('run',matlabbatch);
            disp([suitCBRegions{2,r} ' resliced'])
        end
    case 'pcm_cb_normalise' %normalisation into suit space - requires suit analysis to be run (see SUIT section above)
        
        sn=varargin{1};
        cd([baseDir '/imaging/suit/']);
        
        disp(['suit_reslicing ' subj_name{sn}])
        
        outDir = [cerebellumDir '/' subj_name{sn} '/'];
        
        %identify Beta filenames corresponding to prep and prod for normalisation
        cd(fullfile(glmDir, subj_name{sn})); %load SPM data
        load SPM;
        nrruns=length(SPM.nscan);
        
        runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
        prep      =[0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0];
        prep=[repmat(prep,1,nrruns) runBSL];
        
        prod      =[1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0];
        prod=[repmat(prod,1,nrruns) runBSL];
        
        prepProd = prep + prod;
        [~, col] = find(prepProd > 0);
        
        P={SPM.Vbeta(1:126).fname}';
        Pselect=[];
        for i=1:length(col)
            Pselect{i,1}= P{col(i)};
        end
        
        PselectIn = fullfile(glmDir, subj_name{sn}, Pselect);
        maskName = 'maskbrainSUIT.nii';
        filenames = fullfile(suitDir, subj_name{sn}, maskName);
        filenames = [filenames PselectIn'];
        outnames = [{fullfile(cerebellumDir, subj_name{sn}, maskName)}; fullfile(cerebellumDir, subj_name{sn}, Pselect)]';
        
        % prepare files for input
        affine = {[anatDir '/' subj_name{sn} '/' 'Affine_' subj_name{sn} '_anatomical_seg1.mat']};
        flowfield = {[anatDir '/' subj_name{sn} '/' 'u_a_' subj_name{sn} '_anatomical_seg1.nii']};
        
        mask = {[anatDir '/' subj_name{sn} '/' 'c_' subj_name{sn} '_anatomical_pcereb.nii']};
        
        % prepare struct for function
        job.subj.affineTr = affine; %fill job.subj. struct with respective items
        job.subj.flowfield = flowfield;
        job.subj.resample = filenames;
        job.subj.mask = mask;
        job.subj.outname = outnames;
        
        %function
        suit_reslice_dartel(job)
    case 'pcm_cb_preWhiten' %pre-whiten cerebellar betas ready for PCM
        
        %T = []; %cannot save all together due to memory restrictions %
        s=varargin{1}; blueBear = varargin{2};
        
        cd(cerebellumDir)
        
        R = region('roi_image', fullfile(cerebellumDir, 'atlasSUIT', 'Lobules-SUIT.nii'),1);
        R.name = 'cerebellum'; %use toolbox to define, then add name
        
        R = region_calcregions(R, 'voxelspace', fullfile(cerebellumDir, subj_name{s}, 'beta_0001.nii'));
        
        out = [roiCbDir '/' 'wholeCerebellum_roi'];
        save(strjoin(out,''), 'R'); %save as file
        
        
        for sn=s
            fprintf('%d.',sn); fprintf('\n')
            load([glmDir, '/', subj_name{sn}, '/', 'SPM.mat'], 'SPM')
            load([roiCbDir, '/wholeCerebellum_roi.mat'], 'R')
            
            V = SPM.xY.VY;
            
            %replace fnames for bluebear compatibility
            if blueBear == 1
                for i=1:length(V)
                    V(i).fname = strrep(V(i).fname,'\','/');
                    V(i).fname = strrep(V(i).fname,'Z:','/rds/projects/k/kornyshk-kornyshevalab');
                end
            else
            end
            
            S=[];
            
            for r=1:length(R)
                P=[];
                Y = region_getdata(V,R);
                
                [betaW,resMS,~,beta] = rsa.spm.noiseNormalizeBeta(Y,SPM);
                
                P.betaW = {betaW};
                P.betaUW = {bsxfun(@rdivide,beta,sqrt(resMS))};
                P.betaRAW = {beta};
                P.resMS = {resMS};
                P.SN = sn;
                P.region = r;
                
                %                 T = addstruct(T,S); %cannot save all together due to memory restrictions
                S = addstruct(S, P);
                fprintf('%d.',r)
            end
            fprintf('\n');
            
            save(fullfile(roiCbDir, [subj_name{sn} '_wholePreWhitened_betas.mat']),'-struct','S');
        end
        
        %         save(fullfile(roiCbDir, 'preWhitened_betas.mat'),'-struct','T');  %cannot save all together due to memory restrictions
    case 'pcm_cb_preWhiten_suit' %pre-whiten data from cerebellar ROIs ready for PCM
        
        %T = []; %cannot save all together due to memory restrictions %
        s=varargin{1}; blueBear = varargin{2};
        
        for sn=s
            fprintf('%d.',sn); fprintf('\n')
            load([glmDir, '/', subj_name{sn}, '/', 'SPM.mat'], 'SPM')
            load([roiCbDir, '/', subj_name{sn}, '_cerebellum_roi.mat'], 'R')
            
            V = SPM.xY.VY;
            
            %replace fnames for bluebear compatibility
            if blueBear == 1
                for i=1:length(V)
                    V(i).fname = strrep(V(i).fname,'\','/');
                    V(i).fname = strrep(V(i).fname,'Z:','/rds/projects/k/kornyshk-kornyshevalab');
                end
            else
            end
            
            S=[];
            
            for r=1:length(R)
                P=[];
                Y = region_getdata(V,R{r});
                
                [betaW,resMS,~,beta] = rsa.spm.noiseNormalizeBeta(Y,SPM);
                
                P.betaW = {betaW};
                P.betaUW = {bsxfun(@rdivide,beta,sqrt(resMS))};
                P.betaRAW = {beta};
                P.resMS = {resMS};
                P.SN = sn;
                P.region = r;
                
                %                 T = addstruct(T,S); %cannot save all together due to memory restrictions
                S = addstruct(S, P);
                fprintf('%d.',r)
            end
            fprintf('\n');
            
            save(fullfile(roiCbDir, [subj_name{sn} '_preWhitened_betas.mat']),'-struct','S');
        end
        
        %         save(fullfile(roiCbDir, 'preWhitened_betas.mat'),'-struct','T');  %cannot save all together due to memory restrictions
    case 'pcm_cb_define_lobule_searchlight'
        
        radius=16;
        numVox=160;
        cd([cerebellumDir '/atlasSUIT'])
        
        for r=1:length(suitCBRegions)
            
            V=spm_vol(['r' suitCBRegions{2,r} '.nii']); %preceded by case suit_make_mask
            X=spm_read_vols(V);
            [i,j,k]=ind2sub(size(X),find(X~=0));
            vox=[i j k];
            
            [LI,voxmin,voxmax,n]=lmva_voxelselection(vox(:,:)',vox',[radius numVox],V.mat,V.dim,[], ['volsearch160_' suitCBRegions{2,r} '.nii']);
            save(['volsearch160_' suitCBRegions{2,r} '.mat'], 'vox', 'LI', 'voxmin', 'voxmax', 'n')
        end
    case 'pcm_cb_run_lobule_searchlight'
        
        %load representational models
        modelDir = [modelDir '/onePhase']; %we want models with one phase only
        cd(modelDir)
        files = dir('*.mat');
        for i=1:length(files)
            load(files(i).name)
            models.(D.modelName) = D;
        end
        clear('D')
        
        cd(glmDir);
        
        nrruns=length(run);
        runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
        prod      =[1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0];
        prod=[repmat(prod,1,nrruns) runBSL];
        
        condc=repmat(1:4,1,length(run))'; % extract conditions (leave out errors!)
        runc=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]'; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
        out = {fullfile(pcmSearchDir, 'pcm_left_lobule_5.nii')};
        
        timingModel.G = pcm_estGCrossval(models.temp.data,runc,condc);
        orderModel.G = pcm_estGCrossval(models.ord.data,runc,condc);
        integratedModel.G = pcm_estGCrossval(models.int.data,runc,condc);
        
        % Order model
        M{1}.type       = 'component';
        M{1}.numGparams = 1;
        M{1}.Gc         = orderModel.G;
        M{1}.name       = 'O';
        
        %Timing model
        M{2}.type       = 'component';
        M{2}.numGparams = 1;
        M{2}.Gc         = timingModel.G;
        M{2}.name       = 'T';
        
        % Integrated model
        M{3}.type       = 'component';
        M{3}.numGparams = 1;
        M{3}.Gc         = integratedModel.G;
        M{3}.name       = 'I';
        
        %generate combination models
        [M, CompIdx] = pcm_constructModelFamily(M);
        
        PselectAll = cell(1, length(anaSubj)); loopCount = 1;
        SPMfiles = cell(length(anaSubj),1);
        for i=anaSubj
            
            SPMfiles{loopCount} = load([subj_name{i}, '/SPM.mat'],'SPM');
            
            [~,col] = find(prod>0);
            P={SPMfiles{loopCount}.SPM.Vbeta(1:126).fname}';
            Pselect=cell(length(col),1);
            
            for j=1:length(col)
                Pselect{j,1}= P{col(j)}; %concats all beta filenames for all participants
            end
            Pselect = strcat(fullfile(cerebellumDir, subj_name{i}, '/'), Pselect);
            
            PselectAll{loopCount} = Pselect;
            loopCount = loopCount + 1;
        end
        
        %tstart = tic
        pcm_searchlight(fullfile(cerebellumDir, 'atlasSUIT', 'volsearch160_left_lobule_5.mat'),Pselect,PselectAll,out,@runPCMSearchlight,SPMfiles,'params',{condc,runc,M, CompIdx});
        %telapsed = toc(tstart)
    case 'pcm_cb_reslice' %reslice cerebellar structures into functional resolution - for voxel selection in later searchlight
        
        sn = varargin{1};
        
        refImageDir = [glmDir, '/', subj_name{sn}]; %directories for functional reference image (beta 1)
        cerebellumImageDir = [cerebellumDir, '/', subj_name{sn}]; %and for cerebellar images
        
        for r=1:length(allcbRegions) %loop through cerebellar regions and reslice them to beta image resolution
            
            matlabbatch{1}.spm.spatial.realign.write.data = {[refImageDir, '/beta_0001.nii']; [cerebellumImageDir, '/', subj_name{sn}, '_', allcbRegions{r}, '.nii']};
            matlabbatch{1}.spm.spatial.realign.write.roptions.which = [2 1];
            matlabbatch{1}.spm.spatial.realign.write.roptions.interp = 4;
            matlabbatch{1}.spm.spatial.realign.write.roptions.wrap = [0 0 0];
            matlabbatch{1}.spm.spatial.realign.write.roptions.mask = 1;
            matlabbatch{1}.spm.spatial.realign.write.roptions.prefix = 'r';
            
            spm_jobman('run',matlabbatch);
            disp([allcbRegions{r} ' resliced'])
        end
    case 'pcm_cb_make_mask'  %SUBCORTICAL SEARCHLIGHT ANALYSIS - Makes restricted analysis mask for MVA
        
        s=varargin{1};
        
        for i=1:length(allcbRegions)
            funMask=fullfile(glmDir, subj_name{s},'maskbrain.nii');
            omask=fullfile(cerebellumDir, subj_name{s},['mr' subj_name{s} '_' allcbRegions{i} '.nii']); %output mask to be used in the future
            subcort = fullfile(cerebellumDir, subj_name{s},['r' subj_name{s} '_' allcbRegions{i} '.nii']);
            
            spm_imcalc({funMask,subcort},omask,'i1 >0.01 & i2 > 0.1',{}); %recorded activity in brain (grey + white matter)
        end
    case 'pcm_cb_makeROIs' %CB ANALYSIS - uses region toolbox to define R struct for analysis
        
        s=varargin{1};
        R=cell(length(cbRegions), 1);
        cd(fullfile(cerebellumDir, subj_name{s}))
        
        for i=1:length(cbRegions)%for each subcort region
            R{i} = region('roi_image',[subj_name{s} '_' cbRegions{i} '.nii'],1,cbRegions{i}); %'mr'
            R{i}.name = [subj_name{s} '_' cbRegions{i}]; %use toolbox to define, then add name
        end%for each subcort region
        
        R = region_calcregions(R, 'voxelspace', fullfile(glmDir, subj_name{s}, 'beta_0001.nii'));
        
        out = [roiCbDir '/' subj_name{s} '_cerebellum_roi'];
        save(strjoin(out,''), 'R'); %save as participant file which holds all regions
    case 'pcm_cb_preWhiten_ceres' %pre-whiten data from cerebellar ROIs ready for PCM
        
        %T = []; %cannot save all together due to memory restrictions %
        s=varargin{1}; blueBear = varargin{2};
        
        for sn=s
            fprintf('%d.',sn); fprintf('\n')
            load([glmDir, '/', subj_name{sn}, '/', 'SPM.mat'], 'SPM')
            load([roiCbDir, '/', subj_name{sn}, '_cerebellum_roi.mat'], 'R')
            
            V = SPM.xY.VY;
            
            %replace fnames for bluebear compatibility
            if blueBear == 1
                for i=1:length(V)
                    V(i).fname = strrep(V(i).fname,'\','/');
                    V(i).fname = strrep(V(i).fname,'Z:','/rds/projects/k/kornyshk-kornyshevalab');
                end
            else
            end
            
            S=[];
            
            for r=1:length(R)
                P=[];
                Y = region_getdata(V,R{r});
                
                [betaW,resMS,~,beta] = rsa.spm.noiseNormalizeBeta(Y,SPM);
                
                P.betaW = {betaW};
                P.betaUW = {bsxfun(@rdivide,beta,sqrt(resMS))};
                P.betaRAW = {beta};
                P.resMS = {resMS};
                P.SN = sn;
                P.region = r;
                
                %                 T = addstruct(T,S); %cannot save all together due to memory restrictions
                S = addstruct(S, P);
                fprintf('%d.',r)
            end
            fprintf('\n');
            
            save(fullfile(roiCbDir, [subj_name{sn} '_preWhitened_betas.mat']),'-struct','S');
        end
        
        %         save(fullfile(roiCbDir, 'preWhitened_betas.mat'),'-struct','T');  %cannot save all together due to memory restrictions
    case 'pcm_cb_concatData'
        
        cd(roiCbDir)
        T=[];
        %         betaRAW={}; betaUW = {}; betaW = {}; region = {}; resMS = {}; SN = {};
        for i=anaSubj
            S = load([subj_name{i}, '_preWhitened_betas.mat']);
            %             betaRAW= [betaRAW; S.betaRAW{1}];
            %             betaUW = [betaUW;  S.betaUW{1}];
            %             betaW  = [betaW;   S.betaW{1}];
            %             region = [region; S.region];
            %             resMS  = [resMS; S.resMS{1}];
            %             SN     = [SN; S.SN];
            T = addstruct(T, S);
        end
        
        %         save('preWhitened_betas.mat', 'betaRAW', 'betaUW', 'betaW', 'region', 'resMS', 'SN')
        save('preWhitened_betas.mat', 'T', '-v7.3')
    case 'pcm_cb_fitModels_Prep' %PCM during prep phase only (4 conditions)
        
        modelDir = [modelDir '/onePhase']; %we want models with one phase only
        
        %load representational models
        cd(modelDir)
        files = dir('*.mat');
        for i=1:length(files)
            load(files(i).name)
            models.(D.modelName) = D;
        end
        clear('D')
        
        %load subcortical data for analysis
        W = load(fullfile(roiCbDir, 'preWhitened_betas.mat'));
        W = W.T;
        
        %define condition variables
        runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
        prep      =[0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0];
        prep=[repmat(prep,1,length(run)) runBSL];
        
        c=repmat(1:4,1,length(run))'; % extract conditions (leave out errors!)
        runc=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]'; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
        
        timingModel.G = pcm_estGCrossval(models.temp.data,runc,c);
        orderModel.G = pcm_estGCrossval(models.ord.data,runc,c);
        integratedModel.G = pcm_estGCrossval(models.int.data,runc,c);
        
        [~,col] = find(prep>0); %identify relevant beta files and assign to pselect
        
        for r=1:length(cbRegions)
            
            loopCounter = 1;
            for i=anaSubj
                %YTemp = W.betaUW{W.SN == i & W.region == r}; %univariate prewhiten
                YTemp = W.betaW{W.SN == i & W.region == r}; %multivariate prewhiten
                Y{:,loopCounter} = YTemp(col, :);
                loopCounter = loopCounter + 1;
            end
            
            for i=1:length(Y)
                G_hat(:,:,i)=pcm_estGCrossval(Y{:,i},runc,c);
            end
            
            Gm = mean(G_hat,3); % Mean estimate
            
            figure
            subplot(2,4,1);
            H = eye(4)-ones(4)/4;
            imagesc(H*Gm*H');
            title('Empirical Data')
            
            labels = {'O1T1', 'O1T2', 'O2T1', 'O2T2'};
            C= pcm_indicatorMatrix('allpairs',(1:4)');
            [COORD,~]=pcm_classicalMDS(Gm);
            subplot(2,4,2);
            plot(COORD(:,1),COORD(:,2),'o');
            text(COORD(:,1),COORD(:,2),labels ,'VerticalAlignment','bottom','HorizontalAlignment','center')
            % axis equal;
            
            % visualise models
            subplot(2,4,5);
            imagesc(orderModel.G);
            title('Order control')
            
            subplot(2,4,6);
            imagesc(timingModel.G);
            title('Timing control')
            
            subplot(2,4,7);
            imagesc(integratedModel.G);
            title('Integrated control')
            
            % ----------------------------------------------------------------
            % Now build the models
            % Model 1: Null model for baseline: here we use a model which has all finger
            % Patterns be independent - i.e. all finger pairs are equally far away from
            % each other
            %             M{1}.type       = 'component';
            %             M{1}.numGparams = 1;
            %             M{1}.Gc         = zeros(4);
            %             M{1}.name       = 'null';
            
            % Model 2: Order model, derived from simulations with
            % high order decoding
            M{1}.type       = 'component';
            M{1}.numGparams = 1;
            M{1}.Gc         = orderModel.G;
            M{1}.name       = 'O';
            
            % Model 3: Timing model, derived from simulations with
            % high timing decoding
            M{2}.type       = 'component';
            M{2}.numGparams = 1;
            M{2}.Gc         = timingModel.G;
            M{2}.name       = 'T';
            
            % Model 4: Integrated model, derived from simulations with
            % high integrated decoding
            M{3}.type       = 'component';
            M{3}.numGparams = 1;
            M{3}.Gc         = integratedModel.G;
            M{3}.name       = 'I';
            
            %generate combination models
            M = pcm_constructModelFamily(M);
            
            % Model end: Free model as Noise ceiling
            %             M{end+1}.type       = 'freechol';
            M{end+1}.type     = 'freedirect';
            M{end}.numCond    = 4;
            M{end}.name       = 'noiseceiling';
            M{end}            = pcm_prepFreeModel(M{end});
            
            runEffect  = 'fixed';
            
            % Fit the models on the group level
            [Tgroup,theta] = pcm_fitModelGroup(Y,M,runc,c,'runEffect',runEffect,'fitScale',1);
            
            % Fit the models through cross-subject crossvalidation
            [Tcross,thetaCr] = pcm_fitModelGroupCrossval(Y,M,runc,c,'runEffect',runEffect,'groupFit',theta,'fitScale',1);
            
            % Provide a plot of the crossvalidated likelihoods
            subplot(2,4,[4 8]);
            T = pcm_plotModelLikelihood_RY(Tcross,M,'upperceil',Tgroup.likelihood(:,length(M)));
            title(['Preparation in ' cbRegions{r}])
            
            T.region = ones(length(T.likelihood),1)*r;
            T.phase = ones(length(T.likelihood),1)*1; %1 = prep, 2 = prod
            
            save([pcmDir '/data/cerebellum/' cbRegions{r} '_prepPCM.mat'],'Tgroup', 'Tcross', 'T', 'M', 'Gm', 'C')
            clear('M')
        end
    case 'pcm_cb_fitModels_Prod' %PCM during prep phase only (4 conditions)
        
        modelDir = [modelDir '/onePhase']; %we want models with one phase only
        
        %load representational models
        cd(modelDir)
        files = dir('*.mat');
        for i=1:length(files)
            load(files(i).name)
            models.(D.modelName) = D;
        end
        clear('D')
        
        %load subcortical data for analysis
        W = load(fullfile(roiCbDir, 'preWhitened_betas.mat'));
        W = W.T;
        
        %define condition variables
        runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
        prod      =[1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0];
        prod=[repmat(prod,1,length(run)) runBSL];
        
        c=repmat(1:4,1,length(run))'; % extract conditions (leave out errors!)
        runc=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]'; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
        
        timingModel.G = pcm_estGCrossval(models.temp.data,runc,c);
        orderModel.G = pcm_estGCrossval(models.ord.data,runc,c);
        integratedModel.G = pcm_estGCrossval(models.int.data,runc,c);
        
        [~,col] = find(prod>0); %identify relevant beta files and assign to pselect
        
        for r=1:length(cbRegions)
            
            loopCounter = 1;
            for i=anaSubj
                %YTemp = W.betaUW{W.SN == i & W.region == r}; %univariate prewhiten
                YTemp = W.betaW{W.SN == i & W.region == r}; %multivariate prewhiten
                Y{:,loopCounter} = YTemp(col, :);
                loopCounter = loopCounter + 1;
            end
            
            for i=1:length(Y)
                G_hat(:,:,i)=pcm_estGCrossval(Y{:,i},runc,c);
            end
            
            Gm = mean(G_hat,3); % Mean estimate
            
            figure
            subplot(2,4,1);
            H = eye(4)-ones(4)/4;
            imagesc(H*Gm*H');
            title('Empirical Data')
            
            %             C= pcm_indicatorMatrix('allpairs',[1:4]');
            %             [COORD,l]=pcm_classicalMDS(Gm,'contrast',C);
            %             subplot(2,4,2);
            %             plot(COORD(:,1),COORD(:,2),'o');
            %             axis equal;
            
            labels = {'O1T1', 'O1T2', 'O2T1', 'O2T2'};
            C= pcm_indicatorMatrix('allpairs',(1:4)');
            [COORD,~]=pcm_classicalMDS(Gm);
            subplot(2,4,2);
            plot(COORD(:,1),COORD(:,2),'o');
            text(COORD(:,1),COORD(:,2),labels ,'VerticalAlignment','bottom','HorizontalAlignment','center')
            % axis equal;
            
            % visualise models
            subplot(2,4,5);
            imagesc(orderModel.G);
            title('Order control')
            
            subplot(2,4,6);
            imagesc(timingModel.G);
            title('Timing control')
            
            subplot(2,4,7);
            imagesc(integratedModel.G);
            title('Integrated control')
            
            % ----------------------------------------------------------------
            % Now build the models
            % Model 1: Null model for baseline: here we use a model which has all finger
            % Patterns be independent - i.e. all finger pairs are equally far away from
            % each other
            %             M{1}.type       = 'component';
            %             M{1}.numGparams = 1;
            %             M{1}.Gc         = zeros(4);
            %             M{1}.name       = 'null';
            
            % Model 2: Order model, derived from simulations with
            % high order decoding
            M{1}.type       = 'component';
            M{1}.numGparams = 1;
            M{1}.Gc         = orderModel.G;
            M{1}.name       = 'O';
            
            % Model 3: Timing model, derived from simulations with
            % high timing decoding
            M{2}.type       = 'component';
            M{2}.numGparams = 1;
            M{2}.Gc         = timingModel.G;
            M{2}.name       = 'T';
            
            % Model 4: Integrated model, derived from simulations with
            % high integrated decoding
            M{3}.type       = 'component';
            M{3}.numGparams = 1;
            M{3}.Gc         = integratedModel.G;
            M{3}.name       = 'I';
            
            %generate combination models
            M = pcm_constructModelFamily(M);
            
            % Model end: Free model as Noise ceiling
            %             M{end+1}.type       = 'freechol';
            M{end+1}.type     = 'freedirect';
            M{end}.numCond    = 4;
            M{end}.name       = 'noiseceiling';
            M{end}            = pcm_prepFreeModel(M{end});
            
            runEffect  = 'fixed';
            
            % Fit the models on the group level
            [Tgroup,theta] = pcm_fitModelGroup(Y,M,runc,c,'runEffect',runEffect,'fitScale',1);
            
            % Fit the models through cross-subject crossvalidation
            [Tcross,thetaCr] = pcm_fitModelGroupCrossval(Y,M,runc,c,'runEffect',runEffect,'groupFit',theta,'fitScale',1);
            
            % Provide a plot of the crossvalidated likelihoods
            subplot(2,4,[4 8]);
            T = pcm_plotModelLikelihood_RY(Tcross,M,'upperceil',Tgroup.likelihood(:,length(M)));
            title(['Production in ' cbRegions{r}])
            
            T.region = ones(length(T.likelihood),1)*r;
            T.phase = ones(length(T.likelihood),1)*2; %1 = prep, 2 = prod
            
            save([pcmDir '/data/cerebellum/' cbRegions{r} '_prodPCM.mat'],'Tgroup', 'Tcross', 'T', 'M', 'Gm', 'C')
            clear('M')
        end
    case 'pcm_cb_plotGroup'
        
        phase = {'Preparation', 'Production'};
        %         pcmDataDir = [pcmDir '/data/freedirect']; %PCM data directory
        pcmDataDir = [pcmDir '/data/cb']; %PCM data directory
        %                 pcmDataDir = [pcmDir '/data_preFuncMask/data/freedirect']; %PCM data directory
        %load prep and prod for all regions
        cd(pcmDataDir)
        files = dir('*.mat');
        for i=1:length(files) %load data from ROIs into struct
            Y = load(files(i).name);
            R(i) = Y;
        end
        
        cbRegions = regexprep(cbRegions, '_',' '); %change underscores to spaces in title names
        
        figure
        for i=1:length(R)/2
            subplot(4,2,i)
            pcm_plotModelLikelihood_RY(R(i).Tcross,R(i).M,'upperceil',R(i).Tgroup.likelihood(:,length(R(i).M)));
            title([phase{unique(R(i).T.phase)} ' in ' cbRegions{unique(R(i).T.region)}])
        end
        
        figure
        for i=9:length(R)
            subplot(4,2,i-8)
            pcm_plotModelLikelihood_RY(R(i).Tcross,R(i).M,'upperceil',R(i).Tgroup.likelihood(:,length(R(i).M)));
            title([phase{unique(R(i).T.phase)} ' in ' cbRegions{unique(R(i).T.region)}])
        end
        
        figure
        for i=1:length(R)/2
            labels = {'O1T1', 'O1T2', 'O2T1', 'O2T2'};
            C= pcm_indicatorMatrix('allpairs',(1:4)');
            [COORD,l]=pcm_classicalMDS(R(i).Gm);
            subplot(4,2,i);
            plot(COORD(:,1),COORD(:,2),'o');
            text(COORD(:,1),COORD(:,2),labels ,'VerticalAlignment','bottom','HorizontalAlignment','center')
            % axis equal;
            title([phase{unique(R(i).T.phase)} ' in ' cbRegions{unique(R(i).T.region)}])
        end
        
        figure
        for i=9:length(R)
            labels = {'O1T1', 'O1T2', 'O2T1', 'O2T2'};
            C= pcm_indicatorMatrix('allpairs',(1:4)');
            [COORD,l]=pcm_classicalMDS(R(i).Gm);
            subplot(4,2,i-8);
            plot(COORD(:,1),COORD(:,2),'o');
            text(COORD(:,1),COORD(:,2),labels ,'VerticalAlignment','bottom','HorizontalAlignment','center')
            % axis equal;
            title([phase{unique(R(i).T.phase)} ' in ' cbRegions{unique(R(i).T.region)}])
        end
    case 'pcm_cb_define_searchlight'
        
        s=varargin{1};
        
        radius=16; %maximum radius for each searchlight
        numVox=160; %maximum number of voxels per searchlight
        
        cd(fullfile(cerebellumDir, subj_name{s}));
        V=spm_vol('maskbrainSUIT.nii'); %preceded by case pcm_cb_makeMask
        X=spm_read_vols(V);
        [i,j,k]=ind2sub(size(X),find(X~=0));
        vox=[i j k];
        
        [LI,voxmin,voxmax,n]=lmva_voxelselection(vox(:,:)',vox',[radius numVox],V.mat,V.dim,[],'mva160_numvoxSUIT.nii');
        save volsearch160SUIT.mat vox LI voxmin voxmax n
        
    case 'pcm_cortical_makeROIs'
        
        s=varargin{1};
        
        %sphere
        mni=[...
            -36 -22 53; -21 -12 60; -8 12 57; -32 -54 56; ... %LM1, LPMd, LSMA, LSPC
            36 -22 53;  21 -12 60;  8 18 49;  30 -59 46]; %RM1, RPMd, RSMA, RSPC
        radius = 6; %adjust as necessary
        
        R=cell(length(corticalRegions), 1);
        
        for i=1:length(corticalRegions)%for each subcort region
            R{i} = region('sphere', mni(i,:), radius);
            R{i}.name = [subj_name{s} '_' corticalRegions{i}]; %use toolbox to define, then add name
        end%for each subcort region
        
        R = region_calcregions(R, 'voxelspace', fullfile(glmDir, subj_name{s}, 'beta_0001.nii'));
        
        out = [roiCorticalDir '/' subj_name{s} '_cortical_roi'];
        save(strjoin(out,''), 'R'); %save as participant file which holds all regions
    case 'pcm_cortical_preWhiten' %pre-whiten data from subcortical ROIs ready for PCM
        
        T = []; %s=varargin{1};
        
        for s=anaSubj
            fprintf('%d.',s); fprintf('/n')
            load([glmDir, '/', subj_name{s}, '/', 'SPM.mat'])
            load([roiCorticalDir, '/', subj_name{s}, '_cortical_roi.mat'])
            
            V = SPM.xY.VY;
            for r=1:length(R)
                Y = region_getdata(V,R{r});
                
                [betaW,resMS,~,beta] = rsa.spm.noiseNormalizeBeta(Y,SPM);
                
                S.betaW = {betaW};
                S.betaUW = {bsxfun(@rdivide,beta,sqrt(resMS))};
                S.betaRAW = {beta};
                S.resMS = {resMS};
                S.SN = s;
                S.region = r;
                
                T = addstruct(T,S);
                fprintf('%d.',r)
            end
            fprintf('/n');
        end
        
        save(fullfile(roiCorticalDir, 'preWhitened_betas.mat'),'-struct','T');
    case 'pcm_cortical_fitModels_Prep' %PCM during prep phase only (4 conditions)
        
        modelDir = [modelDir '/onePhase']; %we want models with one phase only
        
        %load representational models
        cd(modelDir)
        files = dir('*.mat');
        for i=1:length(files)
            load(files(i).name)
            models.(D.modelName) = D;
        end
        clear('D')
        
        %load subcortical data for analysis
        W = load(fullfile(roiCorticalDir, 'preWhitened_betas.mat'));
        
        %define condition variables
        runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
        prep      =[0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0];
        prep=[repmat(prep,1,length(run)) runBSL];
        
        c=repmat(1:4,1,length(run))'; % extract conditions (leave out errors!)
        runc=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]'; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
        
        timingModel.G = pcm_estGCrossval(models.temp.data,runc,c);
        orderModel.G = pcm_estGCrossval(models.ord.data,runc,c);
        integratedModel.G = pcm_estGCrossval(models.int.data,runc,c);
        
        [~,col] = find(prep>0); %identify relevant beta files and assign to pselect
        
        for r=1:length(corticalRegions)
            
            loopCounter = 1;
            for i=anaSubj
                %YTemp = W.betaUW{W.SN == i & W.region == r}; %univariate prewhiten
                YTemp = W.betaW{W.SN == i & W.region == r}; %multivariate prewhiten
                Y{:,loopCounter} = YTemp(col, :);
                loopCounter = loopCounter + 1;
            end
            
            for i=1:length(Y)
                G_hat(:,:,i)=pcm_estGCrossval(Y{:,i},runc,c);
            end
            
            Gm = mean(G_hat,3); % Mean estimate
            
            figure
            subplot(2,4,1);
            H = eye(4)-ones(4)/4;
            imagesc(H*Gm*H');
            title('Empirical Data')
            
            labels = {'O1T1', 'O1T2', 'O2T1', 'O2T2'};
            C= pcm_indicatorMatrix('allpairs',(1:4)');
            [COORD,~]=pcm_classicalMDS(Gm);
            subplot(2,4,2);
            plot(COORD(:,1),COORD(:,2),'o');
            text(COORD(:,1),COORD(:,2),labels ,'VerticalAlignment','bottom','HorizontalAlignment','center')
            % axis equal;
            
            % visualise models
            subplot(2,4,5);
            imagesc(orderModel.G);
            title('Order control')
            
            subplot(2,4,6);
            imagesc(timingModel.G);
            title('Timing control')
            
            subplot(2,4,7);
            imagesc(integratedModel.G);
            title('Integrated control')
            
            % ----------------------------------------------------------------
            % Now build the models
            % Model 1: Null model for baseline: here we use a model which has all finger
            % Patterns be independent - i.e. all finger pairs are equally far away from
            % each other
            %             M{1}.type       = 'component';
            %             M{1}.numGparams = 1;
            %             M{1}.Gc         = zeros(4);
            %             M{1}.name       = 'null';
            
            % Model 2: Order model, derived from simulations with
            % high order decoding
            M{1}.type       = 'component';
            M{1}.numGparams = 1;
            M{1}.Gc         = orderModel.G;
            M{1}.name       = 'O';
            
            % Model 3: Timing model, derived from simulations with
            % high timing decoding
            M{2}.type       = 'component';
            M{2}.numGparams = 1;
            M{2}.Gc         = timingModel.G;
            M{2}.name       = 'T';
            
            % Model 4: Integrated model, derived from simulations with
            % high integrated decoding
            M{3}.type       = 'component';
            M{3}.numGparams = 1;
            M{3}.Gc         = integratedModel.G;
            M{3}.name       = 'I';
            
            %generate combination models
            M = pcm_constructModelFamily(M);
            
            % Model end: Free model as Noise ceiling
            %M{end+1}.type     = 'freechol';
            M{end+1}.type     = 'freedirect';
            M{end}.numCond    = 4;
            M{end}.name       = 'noiseceiling';
            M{end}            = pcm_prepFreeModel(M{end});
            
            runEffect  = 'fixed';
            
            % Fit the models on the group level
            [Tgroup,theta] = pcm_fitModelGroup(Y,M,runc,c,'runEffect',runEffect,'fitScale',1);
            
            % Fit the models through cross-subject crossvalidation
            [Tcross,thetaCr] = pcm_fitModelGroupCrossval(Y,M,runc,c,'runEffect',runEffect,'groupFit',theta,'fitScale',1);
            
            % Provide a plot of the crossvalidated likelihoods
            subplot(2,4,[4 8]);
            T = pcm_plotModelLikelihood_RY(Tcross,M,'upperceil',Tgroup.likelihood(:,length(M)));
            title(['Preparation in ' corticalRegions{r}])
            
            T.region = ones(length(T.likelihood),1)*r;
            T.phase = ones(length(T.likelihood),1)*1; %1 = prep, 2 = prod
            
            save([pcmDir '/data/cortical/' corticalRegions{r} '_prepPCM.mat'],'Tgroup', 'Tcross', 'T', 'M', 'Gm', 'C')
            clear('M')
        end
    case 'pcm_cortical_fitModels_Prod' %PCM during prep phase only (4 conditions)
        
        modelDir = [modelDir '/onePhase']; %we want models with one phase only
        
        %load representational models
        cd(modelDir)
        files = dir('*.mat');
        for i=1:length(files)
            load(files(i).name)
            models.(D.modelName) = D;
        end
        clear('D')
        
        %load subcortical data for analysis
        W = load(fullfile(roiCorticalDir, 'preWhitened_betas.mat'));
        
        %define condition variables
        runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
        prod      =[1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0];
        prod=[repmat(prod,1,length(run)) runBSL];
        
        c=repmat(1:4,1,length(run))'; % extract conditions (leave out errors!)
        runc=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]'; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
        
        timingModel.G = pcm_estGCrossval(models.temp.data,runc,c);
        orderModel.G = pcm_estGCrossval(models.ord.data,runc,c);
        integratedModel.G = pcm_estGCrossval(models.int.data,runc,c);
        
        [~,col] = find(prod>0); %identify relevant beta files and assign to pselect
        
        for r=1:length(corticalRegions)
            
            loopCounter = 1;
            for i=anaSubj
                %YTemp = W.betaUW{W.SN == i & W.region == r}; %univariate prewhiten
                YTemp = W.betaW{W.SN == i & W.region == r}; %multivariate prewhiten
                Y{:,loopCounter} = YTemp(col, :);
                loopCounter = loopCounter + 1;
            end
            
            for i=1:length(Y)
                G_hat(:,:,i)=pcm_estGCrossval(Y{:,i},runc,c);
            end
            
            Gm = mean(G_hat,3); % Mean estimate
            
            figure
            subplot(2,4,1);
            H = eye(4)-ones(4)/4;
            imagesc(H*Gm*H');
            title('Empirical Data')
            
            %             C= pcm_indicatorMatrix('allpairs',[1:4]');
            %             [COORD,l]=pcm_classicalMDS(Gm,'contrast',C);
            %             subplot(2,4,2);
            %             plot(COORD(:,1),COORD(:,2),'o');
            %             axis equal;
            
            labels = {'O1T1', 'O1T2', 'O2T1', 'O2T2'};
            C= pcm_indicatorMatrix('allpairs',(1:4)');
            [COORD,~]=pcm_classicalMDS(Gm);
            subplot(2,4,2);
            plot(COORD(:,1),COORD(:,2),'o');
            text(COORD(:,1),COORD(:,2),labels ,'VerticalAlignment','bottom','HorizontalAlignment','center')
            % axis equal;
            
            % visualise models
            subplot(2,4,5);
            imagesc(orderModel.G);
            title('Order control')
            
            subplot(2,4,6);
            imagesc(timingModel.G);
            title('Timing control')
            
            subplot(2,4,7);
            imagesc(integratedModel.G);
            title('Integrated control')
            
            % ----------------------------------------------------------------
            % Now build the models
            % Model 1: Null model for baseline: here we use a model which has all finger
            % Patterns be independent - i.e. all finger pairs are equally far away from
            % each other
            %             M{1}.type       = 'component';
            %             M{1}.numGparams = 1;
            %             M{1}.Gc         = zeros(4);
            %             M{1}.name       = 'null';
            
            % Model 2: Order model, derived from simulations with
            % high order decoding
            M{1}.type       = 'component';
            M{1}.numGparams = 1;
            M{1}.Gc         = orderModel.G;
            M{1}.name       = 'O';
            
            % Model 3: Timing model, derived from simulations with
            % high timing decoding
            M{2}.type       = 'component';
            M{2}.numGparams = 1;
            M{2}.Gc         = timingModel.G;
            M{2}.name       = 'T';
            
            % Model 4: Integrated model, derived from simulations with
            % high integrated decoding
            M{3}.type       = 'component';
            M{3}.numGparams = 1;
            M{3}.Gc         = integratedModel.G;
            M{3}.name       = 'I';
            
            %generate combination models
            M = pcm_constructModelFamily(M);
            
            % Model end: Free model as Noise ceiling
            %M{end+1}.type       = 'freechol';
            M{end+1}.type     = 'freedirect';
            M{end}.numCond    = 4;
            M{end}.name       = 'noiseceiling';
            M{end}            = pcm_prepFreeModel(M{end});
            
            runEffect  = 'fixed';
            
            % Fit the models on the group level
            [Tgroup,theta] = pcm_fitModelGroup(Y,M,runc,c,'runEffect',runEffect,'fitScale',1);
            
            % Fit the models through cross-subject crossvalidation
            [Tcross,thetaCr] = pcm_fitModelGroupCrossval(Y,M,runc,c,'runEffect',runEffect,'groupFit',theta,'fitScale',1);
            
            % Provide a plot of the crossvalidated likelihoods
            subplot(2,4,[4 8]);
            T = pcm_plotModelLikelihood_RY(Tcross,M,'upperceil',Tgroup.likelihood(:,length(M)));
            title(['Production in ' corticalRegions{r}])
            
            T.region = ones(length(T.likelihood),1)*r;
            T.phase = ones(length(T.likelihood),1)*2; %1 = prep, 2 = prod
            
            save([pcmDir '/data/cortical/' corticalRegions{r} '_prodPCM.mat'],'Tgroup', 'Tcross', 'T', 'M', 'Gm', 'C')
            clear('M')
        end
    case 'pcm_cortical_yokoi_prep'
        
        modelDir = [modelDir '/onePhase']; %we want models with one phase only
        R=[]; p=[];
        
        %load representational models
        cd(modelDir)
        files = dir('*.mat');
        for i=1:length(files)
            load(files(i).name)
            models.(D.modelName) = D;
        end
        clear('D')
        
        %load subcortical data for analysis
        W = load(fullfile(roiCorticalDir, 'preWhitened_betas.mat'));
        
        %define condition variables
        runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
        prep      =[0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0];
        prep=[repmat(prep,1,length(run)) runBSL];
        
        condc=repmat(1:4,1,length(run))'; % extract conditions (leave out errors!)
        runc=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]'; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
        
        timingModel.G = pcm_estGCrossval(models.temp.data,runc,condc);
        orderModel.G = pcm_estGCrossval(models.ord.data,runc,condc);
        integratedModel.G = pcm_estGCrossval(models.int.data,runc,condc);
        
        [~,col] = find(prep>0); %identify relevant beta files and assign to pselect
        
        % ----------------------------------------------------------------
        % Now build the models
        % Model 1: Null model for baseline: here we use a model which has all finger
        % Patterns be independent - i.e. all finger pairs are equally far away from
        % each other
        %             M{1}.type       = 'component';
        %             M{1}.numGparams = 1;
        %             M{1}.Gc         = zeros(4);
        %             M{1}.name       = 'null';
        
        % Model 2: Order model, derived from simulations with
        % high order decoding
        M{1}.type       = 'component';
        M{1}.numGparams = 1;
        M{1}.Gc         = orderModel.G;
        M{1}.name       = 'O';
        
        % Model 3: Timing model, derived from simulations with
        % high timing decoding
        M{2}.type       = 'component';
        M{2}.numGparams = 1;
        M{2}.Gc         = timingModel.G;
        M{2}.name       = 'T';
        
        % Model 4: Integrated model, derived from simulations with
        % high integrated decoding
        M{3}.type       = 'component';
        M{3}.numGparams = 1;
        M{3}.Gc         = integratedModel.G;
        M{3}.name       = 'I';
        
        %generate combination models
        [M, CompIdx] = pcm_constructModelFamily(M);
        
        %             % Model end: Free model as Noise ceiling
        %             %M{end+1}.type       = 'freechol';
        %             M{end+1}.type     = 'freedirect';
        %             M{end}.numCond    = 4;
        %             M{end}.name       = 'noiseceiling';
        %             M{end}            = pcm_prepFreeModel(M{end});
        
        runEffect  = 'fixed';
        
        
        for r=1:length(corticalRegions)
            
            loopCounter = 1;
            for i=anaSubj
                %YTemp = W.betaUW{W.SN == i & W.region == r}; %univariate prewhiten
                YTemp = W.betaW{W.SN == i & W.region == r}; %multivariate prewhiten
                Y{:,loopCounter} = YTemp(col, :);
                loopCounter = loopCounter + 1;
            end
            
            for i=1:length(Y)
                G_hat(:,:,i)=pcm_estGCrossval(Y{:,i},runc,condc);
            end
            
            Gm = mean(G_hat,3); % Mean estimate
            
            figure
            subplot(2,4,1);
            H = eye(4)-ones(4)/4;
            imagesc(H*Gm*H');
            title('Empirical Data')
            
            labels = {'O1T1', 'O1T2', 'O2T1', 'O2T2'};
            C= pcm_indicatorMatrix('allpairs',(1:4)');
            [COORD,~]=pcm_classicalMDS(Gm);
            subplot(2,4,2);
            plot(COORD(:,1),COORD(:,2),'o');
            text(COORD(:,1),COORD(:,2),labels ,'VerticalAlignment','bottom','HorizontalAlignment','center')
            % axis equal;
            
            % visualise models
            subplot(2,4,5);
            imagesc(orderModel.G);
            title('Order control')
            
            subplot(2,4,6);
            imagesc(timingModel.G);
            title('Timing control')
            
            subplot(2,4,7);
            imagesc(integratedModel.G);
            title('Integrated control')
            
            %%% Yokoi script %%%
            [T,Tcv,theta_cv] = runPCM(Y, condc, runc, M);
            
            % calculate normal logBF
            logBF = bsxfun(@minus, Tcv.likelihood, Tcv.likelihood(:,1));
            noiseceiling = logBF(:,end);
            logBF = logBF(:,1:end-1);
            
            % calculate component logBF
            [PP, logBFc] = pcm_componentPosterior(logBF, CompIdx);
            
            % get PXP (spm_BMS) for logBFc
            for c=1:3
                lme = [logBFc(:,c), zeros(size(logBFc(:,2)))];
                [~,~,~,pxp_] = spm_BMS (lme);
                pxp(:,c) = repmat(pxp_(1), size(lme,1),1);
            end
            
            % get PXP for noise-ceiling logBF (vs null)
            lme = [noiseceiling, zeros(size(noiseceiling))];
            [~,~,~,pxp_] = spm_BMS (lme);
            pxp_ceiling(:,1) = repmat(pxp_(1), size(lme,1),1);
            
            % concatenate results
            p.logBF = logBF;
            p.noiseceiling = noiseceiling;
            p.pxp_ceiling = pxp_ceiling;
            p.logBFc = logBFc;
            p.pxp = pxp;
            p.region = repmat(r,length(pxp),1);
            p.phase = ones(length(pxp),1);
            %             p.sn = repmat(s, length(pxp),1);
            %             p.hemis = repmat(h, length(pxp),1);
            %             p.patch = repmat(p, length(pxp),1);
            %             p.nodeID = repmat(D.nodeID(1), length(pxp),1);
            R = addstruct(R,p);
            
        end
        
        save([pcmDir '/data/cortical/prepPCM_yokoi.mat'],'R')
        cd(fullfile(pcmDir, 'data'))
    case 'pcm_cortical_yokoi_prod'
        
        modelDir = [modelDir '/onePhase']; %we want models with one phase only
        R=[]; p=[];
        
        %load representational models
        cd(modelDir)
        files = dir('*.mat');
        for i=1:length(files)
            load(files(i).name)
            models.(D.modelName) = D;
        end
        clear('D')
        
        %load subcortical data for analysis
        W = load(fullfile(roiCorticalDir, 'preWhitened_betas.mat'));
        
        %define condition variables
        runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
        prod      =[1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0];
        prod=[repmat(prod,1,length(run)) runBSL];
        
        condc=repmat(1:4,1,length(run))'; % extract conditions (leave out errors!)
        runc=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]'; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
        
        timingModel.G = pcm_estGCrossval(models.temp.data,runc,condc);
        orderModel.G = pcm_estGCrossval(models.ord.data,runc,condc);
        integratedModel.G = pcm_estGCrossval(models.int.data,runc,condc);
        
        [~,col] = find(prod>0); %identify relevant beta files and assign to pselect
        
        % ----------------------------------------------------------------
        % Now build the models
        % Model 1: Null model for baseline: here we use a model which has all finger
        % Patterns be independent - i.e. all finger pairs are equally far away from
        % each other
        %             M{1}.type       = 'component';
        %             M{1}.numGparams = 1;
        %             M{1}.Gc         = zeros(4);
        %             M{1}.name       = 'null';
        
        % Model 2: Order model, derived from simulations with
        % high order decoding
        M{1}.type       = 'component';
        M{1}.numGparams = 1;
        M{1}.Gc         = orderModel.G;
        M{1}.name       = 'O';
        
        % Model 3: Timing model, derived from simulations with
        % high timing decoding
        M{2}.type       = 'component';
        M{2}.numGparams = 1;
        M{2}.Gc         = timingModel.G;
        M{2}.name       = 'T';
        
        % Model 4: Integrated model, derived from simulations with
        % high integrated decoding
        M{3}.type       = 'component';
        M{3}.numGparams = 1;
        M{3}.Gc         = integratedModel.G;
        M{3}.name       = 'I';
        
        %generate combination models
        [M, CompIdx] = pcm_constructModelFamily(M);
        
        %             % Model end: Free model as Noise ceiling
        %             %M{end+1}.type       = 'freechol';
        %             M{end+1}.type     = 'freedirect';
        %             M{end}.numCond    = 4;
        %             M{end}.name       = 'noiseceiling';
        %             M{end}            = pcm_prepFreeModel(M{end});
        
        runEffect  = 'fixed';
        
        
        for r=1:length(corticalRegions)
            
            loopCounter = 1;
            for i=anaSubj
                %YTemp = W.betaUW{W.SN == i & W.region == r}; %univariate prewhiten
                YTemp = W.betaW{W.SN == i & W.region == r}; %multivariate prewhiten
                Y{:,loopCounter} = YTemp(col, :);
                loopCounter = loopCounter + 1;
            end
            
            for i=1:length(Y)
                G_hat(:,:,i)=pcm_estGCrossval(Y{:,i},runc,condc);
            end
            
            Gm = mean(G_hat,3); % Mean estimate
            
            figure
            subplot(2,4,1);
            H = eye(4)-ones(4)/4;
            imagesc(H*Gm*H');
            title('Empirical Data')
            
            labels = {'O1T1', 'O1T2', 'O2T1', 'O2T2'};
            C= pcm_indicatorMatrix('allpairs',(1:4)');
            [COORD,~]=pcm_classicalMDS(Gm);
            subplot(2,4,2);
            plot(COORD(:,1),COORD(:,2),'o');
            text(COORD(:,1),COORD(:,2),labels ,'VerticalAlignment','bottom','HorizontalAlignment','center')
            % axis equal;
            
            % visualise models
            subplot(2,4,5);
            imagesc(orderModel.G);
            title('Order control')
            
            subplot(2,4,6);
            imagesc(timingModel.G);
            title('Timing control')
            
            subplot(2,4,7);
            imagesc(integratedModel.G);
            title('Integrated control')
            
            %%% Yokoi script %%%
            [T,Tcv,theta_cv] = runPCM(Y, condc, runc, M);
            
            % calculate normal logBF
            logBF = bsxfun(@minus, Tcv.likelihood, Tcv.likelihood(:,1));
            noiseceiling = logBF(:,end);
            logBF = logBF(:,1:end-1);
            
            % calculate component logBF
            [PP, logBFc] = pcm_componentPosterior(logBF, CompIdx);
            
            % get PXP (spm_BMS) for logBFc
            for c=1:3
                lme = [logBFc(:,c), zeros(size(logBFc(:,2)))];
                [~,~,~,pxp_] = spm_BMS (lme);
                pxp(:,c) = repmat(pxp_(1), size(lme,1),1);
            end
            
            % get PXP for noise-ceiling logBF (vs null)
            lme = [noiseceiling, zeros(size(noiseceiling))];
            [~,~,~,pxp_] = spm_BMS (lme);
            pxp_ceiling(:,1) = repmat(pxp_(1), size(lme,1),1);
            
            % concatenate results
            p.logBF = logBF;
            p.noiseceiling = noiseceiling;
            p.pxp_ceiling = pxp_ceiling;
            p.logBFc = logBFc;
            p.pxp = pxp;
            p.region = repmat(r,length(pxp),1);
            p.phase = repmat(2,length(pxp),1);
            %             p.sn = repmat(s, length(pxp),1);
            %             p.hemis = repmat(h, length(pxp),1);
            %             p.patch = repmat(p, length(pxp),1);
            %             p.nodeID = repmat(D.nodeID(1), length(pxp),1);
            R = addstruct(R,p);
            
        end
        
        save([pcmDir '/data/cortical/prodPCM_yokoi.mat'],'R')
        cd(fullfile(pcmDir, 'data'))
    case 'pcm_cortical_plotGroup'
        
        phase = {'Preparation', 'Production'};
        pcmDataDir = [pcmDir '/data/cortical']; %PCM data directory
        
        %load prep and prod for all regions
        cd(pcmDataDir)
        files = dir('*.mat');
        for i=1:length(files) %load data from ROIs into struct
            Y = load(files(i).name);
            R(i) = Y;
        end
        
        figure
        for i=1:length(R)/2
            subplot(4,2,i)
            pcm_plotModelLikelihood_RY(R(i).Tcross,R(i).M,'upperceil',R(i).Tgroup.likelihood(:,length(R(i).M)));
            title([phase{unique(R(i).T.phase)} ' in ' corticalRegions{unique(R(i).T.region)}])
        end
        
        figure
        for i=9:length(R)
            subplot(4,2,i-8)
            pcm_plotModelLikelihood_RY(R(i).Tcross,R(i).M,'upperceil',R(i).Tgroup.likelihood(:,length(R(i).M)));
            title([phase{unique(R(i).T.phase)} ' in ' corticalRegions{unique(R(i).T.region)}])
        end
        
        figure
        for i=1:length(R)/2
            labels = {'O1T1', 'O1T2', 'O2T1', 'O2T2'};
            C= pcm_indicatorMatrix('allpairs',(1:4)');
            [COORD,l]=pcm_classicalMDS(R(i).Gm);
            subplot(4,2,i);
            plot(COORD(:,1),COORD(:,2),'o');
            text(COORD(:,1),COORD(:,2),labels ,'VerticalAlignment','bottom','HorizontalAlignment','center')
            % axis equal;
            title([phase{unique(R(i).T.phase)} ' in ' corticalRegions{unique(R(i).T.region)}])
        end
        
        figure
        for i=9:length(R)
            labels = {'O1T1', 'O1T2', 'O2T1', 'O2T2'};
            C= pcm_indicatorMatrix('allpairs',(1:4)');
            [COORD,l]=pcm_classicalMDS(R(i).Gm);
            subplot(4,2,i-8);
            plot(COORD(:,1),COORD(:,2),'o');
            text(COORD(:,1),COORD(:,2),labels ,'VerticalAlignment','bottom','HorizontalAlignment','center')
            % axis equal;
            title([phase{unique(R(i).T.phase)} ' in ' corticalRegions{unique(R(i).T.region)}])
        end
    case 'PCM_normaliseBetaMaps' %%% Cortical PCM Analysis %%% normalises individual beta maps for cortical marsbar ROI analysis
        
        s = varargin{1};
        
        if ~isfolder(pcmGroupDir)
            mkdir(pcmGroupDir) % folder for pcm group dir
        end
        
        load([glmDir, '/', subj_name{s}, '/', 'SPM.mat'],'SPM')
        
        nrruns=length(SPM.nscan);
        
        runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
        prep      =[0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0];
        prep=[repmat(prep,1,nrruns) runBSL];
        
        prod      =[1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0];
        prod=[repmat(prod,1,nrruns) runBSL];
        
        [~,prepCol] = find(prep>0); prepCol = reshape(prepCol,4,[]);
        [~,prodCol] = find(prod>0); prodCol = reshape(prodCol,4,[]);
        col = [prepCol; prodCol]; col = reshape(col,1,[]);
        
        P={SPM.Vbeta(1:126).fname}';
        P = P(col);
        %MVPA accuracy maps
        images= P; % the above loads all regressors for prep and prod
        images = strrep(images,'.nii','');%remove .nii from filename
        defor= fullfile(anatDir, subj_name{s}, [subj_name{s}, '_anatomical_seg_sn.mat']);
        
        sn_images = strcat([glmDir, '/', subj_name{s}, '/'], images, '.nii');
        out_images = strcat([pcmGroupDir, '/'], images, ['_', subj_name{s}, '.nii']);
        spmj_normalization_write(defor, sn_images,'outimages',out_images); %Trilinear interpolation
    case 'PCM_cortical_ROItoNii' %Generates elife ROIs with marsbar and converts to .nii
        
        %%% from Elife 2014 bilateral:
        %         roiOUT=[baseDir, '/imaging/ROI/roi_Elife2014.mat'];
        
        refImageDir = [groupDir '/PCM']; %directories for functional reference image (beta 1)
        cortROIDir = [baseDir, '/imaging/ROI/']; %and for cortical ROIs
        cd(cortROIDir)
        
        mni=[-36 -22 53 ; 36 -22 53 ; -21 -12 60  ; 21 -12 60; -8 12 57;  8 18 49; -32 -54 56; 30 -59 46]; %peaks of overall classifier in elife
        roiName={'LM1','RM1','LPMd','RPMd','LSMA','RSMA','LSPC','RSPC'}; %corresponding names
        
        for i=1:length(roiName)
            
            sphereROI = maroi_sphere(struct('centre',mni(i,:),'radius',9,'label',roiName{i})); %constructs ROIs in marsbar format
            
            %%% Then save:
            saveroi(sphereROI, [roiName{i}, '_elife.mat']); %as .mat
            save_as_image(sphereROI, [roiName{i} '_elife.nii']) %as .nii too
            
            %then reslice into functional resolution:
            matlabbatch{1}.spm.spatial.realign.write.data = {[refImageDir, '/beta_0001_s03.nii']; [roiName{i}, '_elife.nii']};
            matlabbatch{1}.spm.spatial.realign.write.roptions.which = [2 1];
            matlabbatch{1}.spm.spatial.realign.write.roptions.interp = 4;
            matlabbatch{1}.spm.spatial.realign.write.roptions.wrap = [0 0 0];
            matlabbatch{1}.spm.spatial.realign.write.roptions.mask = 1;
            matlabbatch{1}.spm.spatial.realign.write.roptions.prefix = 'r';
            
            spm_jobman('run',matlabbatch);
            disp([roiName{i} ' resliced'])
            
        end%for rois
    case 'PCM_cortical_define_mva_area' %converts RoI from marsbar .nii to voxel coordinate .mat for PCM
        
        rois={'LM1','RM1','LPMd','RPMd','LSMA','RSMA','LSPC','RSPC'}; %corresponding names
        cd(roiDir);
        
        % load respective subcortical .nii and extract x y z coordinates for voxels
        for r=1:length(rois)
            V=spm_vol(['r' rois{r} '_elife.nii']);
            X=spm_read_vols(V);
            [i,j,k]=ind2sub(size(X),find(X~=0));
            vox=[i j k];
            
            LI{1} = sub2ind(V.dim,vox(:,1),vox(:,2),vox(:,3)); %convert x y z coordinates into linear index for voxels
            voxmin = min(vox,[],1); %min x y z coordinates for each voxel
            voxmax = max(vox,[],1); %max as above
            n = size(vox,1); %number of voxels
            
            save([pcmDir '/decodeArea_' rois{r} '.mat'], 'vox', 'LI', 'voxmin', 'voxmax', 'n')
            disp([rois{r} ' done'])
        end
    case 'PCM_cortical_fitModels_ROI' %fits PCM models to data from marsbar-defined ROIs
        
        %         anaSubj = [3,5,6,7,9,10,13,16,17,18,20,21,22,25,26,31,32,34,36,38,39,40,41,42];
        
        rois={'LM1','RM1','LPMd','RPMd','LSMA','RSMA','LSPC','RSPC'}; %corresponding names
        models = prepProdSimu_loadModels(modelDir);
        
        for r=1:length(rois)%for each roi
            
            %load subcortical data for analysis
            loopCounter = 1;
            for s=anaSubj
                %         for s=3
                
                cd(fullfile(glmDir, subj_name{s})); %load SPM data
                load SPM;
                nrruns=length(SPM.nscan);
                
                runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
                prep      =[0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0];
                prep=[repmat(prep,1,nrruns) runBSL];
                
                prod      =[1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0];
                prod=[repmat(prod,1,nrruns) runBSL];
                
                c=repmat(1:8,1,nrruns)'; % extract conditions (leave out errors!)
                run=[1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6]'; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
                
                [~,prepCol] = find(prep>0); prepCol = reshape(prepCol,4,[]);
                [~,prodCol] = find(prod>0); prodCol = reshape(prodCol,4,[]);
                col = [prepCol; prodCol]; col = reshape(col,1,[]);
                
                
                P={SPM.Vbeta(1:126).fname}';
                Pselect=[];
                for i=1:length(col)
                    Pselect{i,1}= P{col(i)};
                end
                
                S = load(fullfile(pcmDir,['/decodeArea_' rois{r} '.mat']));
                
                Pselect = strcat([groupDir, '/PCM/'], strrep(Pselect,'.nii',''), '_', subj_name{s}, '.nii');
                Vin = spm_vol(char(Pselect));
                
                %extract voxels in decoding area from beta files and pass to MVPA function
                linVox=unique(cat(2,S.LI{:})');
                [I,J,K]=ind2sub(Vin(1).dim,linVox);
                X = zeros(length(linVox),length(Vin));
                
                for i=1:length(Vin) %this gives us a voxelN x betaN matrix
                    X(:,i)=spm_sample_vol(Vin(i),double(I),double(J),double(K),0);
                end
                
                [nanidx, ~] = find(isnan(X)); %remove nan values contained in beta image due to signal loss(?)
                nanidx = unique(nanidx);
                X(nanidx,:) = [];
                Y{:,loopCounter}=X';
                
                loopCounter = loopCounter+1;
            end%subj loop
            
            for i=1:length(Y)
                G_hat(:,:,i)=pcm_estGCrossval(Y{:,i},run,c);
            end
            
            Gm = mean(G_hat,3); % Mean estimate
            
            [M, R] = prepProdSimu_prepModels(models,run,c);
            
            figure
            subplot(3,7,[1, 8]);
            H = eye(8)-ones(8)/8;
            imagesc(H*Gm*H');
            title('Empirical Data')
            
            C= pcm_indicatorMatrix('allpairs',[1:8]');
            [COORD,l]=pcm_classicalMDS(Gm,'contrast',C);
            subplot(3,7,15);
            plot(COORD(:,1),COORD(:,2),'o');
            axis equal;
            
            % visualise models
            subplot(3,7,2);
            imagesc(R.orderPrepModel.G);
            title('Order Prep')
            
            subplot(3,7,9);
            imagesc(R.orderProdModel.G);
            title('Order Prod')
            
            subplot(3,7,16);
            imagesc(R.orderMaintModel.G);
            title('Order Maint')
            
            subplot(3,7,3);
            imagesc(R.timingPrepModel.G);
            title('Timing Prep')
            
            subplot(3,7,10);
            imagesc(R.timingProdModel.G);
            title('Timing Prod')
            
            subplot(3,7,17);
            imagesc(R.timingMaintModel.G);
            title('Timing Maint')
            
            subplot(3,7,4);
            imagesc(R.integratedPrepModel.G);
            title('Integrated Prep')
            
            subplot(3,7,11);
            imagesc(R.integratedProdModel.G);
            title('Integrated Prod')
            
            subplot(3,7,18);
            imagesc(R.integratedMaintModel.G);
            title('Integrated Maint')
            
            % Treat the run effect as random or fixed?
            % We are using a fixed run effect here, as we are not interested in the
            % activity relative the the baseline (rest) - so as in RSA, we simply
            % subtract out the mean patttern across all conditions.
            runEffect  = 'fixed';
            
            % Fit the models on the group level
            [Tgroup,theta] = pcm_fitModelGroup(Y,M,run,c,'runEffect',runEffect,'fitScale',1);
            
            % Fit the models through cross-subject crossvalidation
            [Tcross,thetaCr] = pcm_fitModelGroupCrossval(Y,M,run,c,'runEffect',runEffect,'groupFit',theta,'fitScale',1);
            
            % Provide a plot of the crossvalidated likelihoods
            subplot(3,7,[5 6 7 12 13 14 19 20 21]);
            T = pcm_plotModelLikelihood_RY(Tcross,M,'upperceil',Tgroup.likelihood(:,length(M)));
            title(rois{r})
        end
    case 'PCM_cortical_fitModelsPrep_ROI' %PCM during prep phase only in marsbar ROIs (4 conditions)
        
        rois={'LM1','RM1','LPMd','RPMd','LSMA','RSMA','LSPC','RSPC'}; %corresponding names
        modelDir = [modelDir '/onePhase'];
        
        %load 9 representational models
        models = prepProdSimu_loadModels(modelDir);
        
        for r=1:length(rois)%for each roi
            %load subcortical data for analysis
            %         s=varargin{1};
            loopCounter = 1;
            for s=anaSubj
                
                cd(fullfile(glmDir, subj_name{s})); %load SPM data
                load SPM;
                nrruns=length(SPM.nscan);
                
                runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
                prep      =[0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0];
                prep=[repmat(prep,1,nrruns) runBSL];
                
                c=repmat(1:4,1,nrruns)'; % extract conditions (leave out errors!)
                run=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]'; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
                
                [~,col] = find(prep>0); %identify relevant beta files and assign to pselect
                P={SPM.Vbeta(1:126).fname}';
                Pselect=[];
                for i=1:length(col)
                    Pselect{i,1}= P{col(i)};
                end
                
                S = load(fullfile(pcmDir,['/decodeArea_' rois{r} '.mat']));
                Vin = spm_vol(char(Pselect));
                
                %extract voxels in decoding area from beta files and pass to MVPA function
                linVox=unique(cat(2,S.LI{:})');
                [I,J,K]=ind2sub(Vin(1).dim,linVox);
                X = zeros(length(linVox),length(Vin));
                
                for i=1:length(Vin) %this gives us a voxelN x betaN matrix
                    X(:,i)=spm_sample_vol(Vin(i),double(I),double(J),double(K),0);
                end
                
                [nanidx, ~] = find(isnan(X)); %remove nan values contained in beta image due to signal loss(?)
                nanidx = unique(nanidx);
                X(nanidx,:) = [];
                Y{:,loopCounter}=X';
                
                loopCounter = loopCounter+1;
            end%subj loop
            
            for i=1:length(Y)
                G_hat(:,:,i)=pcm_estGCrossval(Y{:,i},run,c);
            end;
            
            Gm = mean(G_hat,3); % Mean estimate
            
            timingModel.G = pcm_estGCrossval(models.temp.data,run,c);
            orderModel.G = pcm_estGCrossval(models.ord.data,run,c);
            integratedModel.G = pcm_estGCrossval(models.int.data,run,c);
            
            figure
            subplot(2,4,1);
            H = eye(4)-ones(4)/4;
            imagesc(H*Gm*H');
            title('Empirical Data')
            
            C= pcm_indicatorMatrix('allpairs',[1:4]');
            [COORD,l]=pcm_classicalMDS(Gm,'contrast',C);
            subplot(2,4,2);
            plot(COORD(:,1),COORD(:,2),'o');
            axis equal;
            
            % visualise models
            subplot(2,4,5);
            imagesc(orderModel.G);
            title('Order control')
            
            subplot(2,4,6);
            imagesc(timingModel.G);
            title('Timing control')
            
            subplot(2,4,7);
            imagesc(integratedModel.G);
            title('Integrated control')
            
            % ----------------------------------------------------------------
            % Now build the models
            % Model 1: Null model for baseline: here we use a model which has all finger
            % Patterns be independent - i.e. all finger pairs are equally far away from
            % each other
            %             M{1}.type       = 'component';
            %             M{1}.numGparams = 1;
            %             M{1}.Gc         = ones(4);
            %             M{1}.name       = 'null';
            
            % Model 2: Order model, derived from simulations with
            % high order decoding
            M{1}.type       = 'component';
            M{1}.numGparams = 1;
            M{1}.Gc         = orderModel.G;
            M{1}.name       = 'O';
            
            % Model 3: Timing model, derived from simulations with
            % high timing decoding
            M{2}.type       = 'component';
            M{2}.numGparams = 1;
            M{2}.Gc         = timingModel.G;
            M{2}.name       = 'T';
            
            % Model 4: Integrated model, derived from simulations with
            % high integrated decoding
            M{3}.type       = 'component';
            M{3}.numGparams = 1;
            M{3}.Gc         = integratedModel.G;
            M{3}.name       = 'I';
            
            %generate combination models, but exclude null model
            %             Mtemp = pcm_constructModelFamily(M(2:end));
            %             M = [M(1) Mtemp];
            M = pcm_constructModelFamily(M);
            
            %         % Model 5: Additive mixture between order and timing models
            %         M{5}.type       = 'component';
            %         M{5}.numGparams = 2;
            %         M{5}.Gc(:,:,1)  = orderModel.G;
            %         M{5}.Gc(:,:,2)  = timingModel.G;
            %         M{5}.name       = 'order + timing';
            
            % Model end: Free model as Noise ceiling
            %             M{end+1}.type       = 'freechol';
            M{end+1}.type       = 'freedirect';
            M{end}.numCond    = 4;
            M{end}.name       = 'noiseceiling';
            M{end}            = pcm_prepFreeModel(M{end});
            
            % Treat the run effect as random or fixed?
            % We are using a fixed run effect here, as we are not interested in the
            % activity relative the the baseline (rest) - so as in RSA, we simply
            % subtract out the mean patttern across all conditions.
            runEffect  = 'fixed';
            
            % Fit the models on the group level
            [Tgroup,theta] = pcm_fitModelGroup(Y,M,run,c,'runEffect',runEffect,'fitScale',1);
            
            % Fit the models through cross-subject crossvalidation
            [Tcross,thetaCr] = pcm_fitModelGroupCrossval(Y,M,run,c,'runEffect',runEffect,'groupFit',theta,'fitScale',1);
            
            % Provide a plot of the crossvalidated likelihoods
            subplot(2,4,[4 8]);
            T = pcm_plotModelLikelihood_RY(Tcross,M,'upperceil',Tgroup.likelihood(:,length(M)));
            title(['Preparation in ' rois{r}])
            
            T.region = ones(length(T.likelihood),1)*r;
            T.phase = ones(length(T.likelihood),1)*1; %1 = prep, 2 = prod
            
            save([pcmDir '/cortical/' rois{r} '_prepPCM.mat'],'Tgroup', 'Tcross', 'T', 'M', 'Gm', 'C')
            
            clear('M')
        end
    case 'PCM_cortical_fitModelsProd_ROI' %PCM during prod phase only in marsbar ROIs (4 conditions)
        
        rois={'LM1','RM1','LPMd','RPMd','LSMA','RSMA','LSPC','RSPC'}; %corresponding names
        modelDir = [modelDir '/onePhase'];
        
        %load 9 representational models
        models = prepProdSimu_loadModels(modelDir);
        
        for r=1:length(rois)%for each roi
            %load subcortical data for analysis
            %         s=varargin{1};
            loopCounter = 1;
            for s=anaSubj
                
                cd(fullfile(glmDir, subj_name{s})); %load SPM data
                load SPM;
                nrruns=length(SPM.nscan);
                
                runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
                prod      =[1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0];
                prod=[repmat(prod,1,nrruns) runBSL];
                
                c=repmat(1:4,1,nrruns)'; % extract conditions (leave out errors!)
                run=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]'; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
                
                [~,col] = find(prod>0); %identify relevant beta files and assign to pselect
                P={SPM.Vbeta(1:126).fname}';
                Pselect=[];
                for i=1:length(col)
                    Pselect{i,1}= P{col(i)};
                end
                
                S = load(fullfile(pcmDir,['/decodeArea_' rois{r} '.mat']));
                Vin = spm_vol(char(Pselect));
                
                %extract voxels in decoding area from beta files and pass to MVPA function
                linVox=unique(cat(2,S.LI{:})');
                [I,J,K]=ind2sub(Vin(1).dim,linVox);
                X = zeros(length(linVox),length(Vin));
                
                for i=1:length(Vin) %this gives us a voxelN x betaN matrix
                    X(:,i)=spm_sample_vol(Vin(i),double(I),double(J),double(K),0);
                end
                
                [nanidx, ~] = find(isnan(X)); %remove nan values contained in beta image due to signal loss(?)
                nanidx = unique(nanidx);
                X(nanidx,:) = [];
                Y{:,loopCounter}=X';
                
                loopCounter = loopCounter+1;
            end%subj loop
            
            for i=1:length(Y)
                G_hat(:,:,i)=pcm_estGCrossval(Y{:,i},run,c);
            end;
            
            Gm = mean(G_hat,3); % Mean estimate
            
            %             for i=1:length(Y)
            %                 [ovr(:,:,i), int(:,:,i), ord(:,:,i), temp(:,:,i)] = prepProdSimu_classify(Y{i});
            %             end
            
            %             for i=1:length(Y)
            %                 [accuracy(i,:), accuracy(i+1,:), accuracy(i+2,:), accuracy(i+3,:)] = prepProdSimu_classify(Y{i});
            %                 accID(i,:) = 1;
            %                 accID(i+1,:) = 2;
            %                 accID(i+2,:) = 3;
            %                 accID(i+3,:) = 4;
            %             end
            
            timingModel.G = pcm_estGCrossval(models.temp.data,run,c);
            orderModel.G = pcm_estGCrossval(models.ord.data,run,c);
            integratedModel.G = pcm_estGCrossval(models.int.data,run,c);
            
            figure
            subplot(2,4,1);
            H = eye(4)-ones(4)/4;
            imagesc(H*Gm*H');
            title('Empirical Data')
            
            C= pcm_indicatorMatrix('allpairs',[1:4]');
            [COORD,l]=pcm_classicalMDS(Gm,'contrast',C);
            subplot(2,4,2);
            plot(COORD(:,1),COORD(:,2),'o');
            axis equal;
            
            % visualise models
            subplot(2,4,5);
            imagesc(orderModel.G);
            title('Order control')
            
            subplot(2,4,6);
            imagesc(timingModel.G);
            title('Timing control')
            
            subplot(2,4,7);
            imagesc(integratedModel.G);
            title('Integrated control')
            
            % ----------------------------------------------------------------
            % Now build the models
            % Model 1: Null model for baseline: here we use a model which has all finger
            % Patterns be independent - i.e. all finger pairs are equally far away from
            % each other
            %             M{1}.type       = 'component';
            %             M{1}.numGparams = 1;
            %             M{1}.Gc         = ones(4);
            %             M{1}.name       = 'null';
            
            % Model 2: Order model, derived from simulations with
            % high order decoding
            M{1}.type       = 'component';
            M{1}.numGparams = 1;
            M{1}.Gc         = orderModel.G;
            M{1}.name       = 'O';
            
            % Model 3: Timing model, derived from simulations with
            % high timing decoding
            M{2}.type       = 'component';
            M{2}.numGparams = 1;
            M{2}.Gc         = timingModel.G;
            M{2}.name       = 'T';
            
            % Model 4: Integrated model, derived from simulations with
            % high integrated decoding
            M{3}.type       = 'component';
            M{3}.numGparams = 1;
            M{3}.Gc         = integratedModel.G;
            M{3}.name       = 'I';
            
            %generate combination models, but exclude null model
            %             Mtemp = pcm_constructModelFamily(M(2:end));
            %             M = [M(1) Mtemp];
            M = pcm_constructModelFamily(M);
            
            %         % Model 5: Additive mixture between order and timing models
            %         M{5}.type       = 'component';
            %         M{5}.numGparams = 2;
            %         M{5}.Gc(:,:,1)  = orderModel.G;
            %         M{5}.Gc(:,:,2)  = timingModel.G;
            %         M{5}.name       = 'order + timing';
            
            % Model end: Free model as Noise ceiling
            %             M{end+1}.type       = 'freechol';
            M{end+1}.type       = 'freedirect';
            M{end}.numCond    = 4;
            M{end}.name       = 'noiseceiling';
            M{end}            = pcm_prepFreeModel(M{end});
            
            % Treat the run effect as random or fixed?
            % We are using a fixed run effect here, as we are not interested in the
            % activity relative the the baseline (rest) - so as in RSA, we simply
            % subtract out the mean patttern across all conditions.
            runEffect  = 'fixed';
            
            % Fit the models on the group level
            [Tgroup,theta] = pcm_fitModelGroup(Y,M,run,c,'runEffect',runEffect,'fitScale',1);
            
            % Fit the models through cross-subject crossvalidation
            [Tcross,thetaCr] = pcm_fitModelGroupCrossval(Y,M,run,c,'runEffect',runEffect,'groupFit',theta,'fitScale',1);
            
            % Provide a plot of the crossvalidated likelihoods
            subplot(2,4,[4 8]);
            T = pcm_plotModelLikelihood_RY(Tcross,M,'upperceil',Tgroup.likelihood(:,length(M)));
            title(['Production in ' rois{r}])
            
            T.region = ones(length(T.likelihood),1)*r;
            T.phase = ones(length(T.likelihood),1)*2; %1 = prep, 2 = prod
            
            save([pcmDir '/cortical/' rois{r} '_prodPCM.mat'],'Tgroup', 'Tcross', 'T', 'M', 'Gm', 'C')
            
            clear('M')
        end
    case 'pcm_cb_make_structs' %extracts each subcortical structure from aseg file, and creates respective nii files
        
        sn = varargin{1};
        
        cbRegionValues = [1:13, 101:113]; %left 1:13, right 101:113 (from READMEnat.pdf files)
        
        for i=1:length(allcbRegions)
            
            cd([cerebellumDir, '/', subj_name{sn}])
            
            matlabbatch{1}.spm.util.imcalc.input = {[cerebellumDir, '/' subj_name{sn} '/' subj_name{sn}, '_asegCB.nii,1']};
            matlabbatch{1}.spm.util.imcalc.output = [subj_name{sn}, '_', allcbRegions{i}];
            matlabbatch{1}.spm.util.imcalc.expression = ['i1 == ', num2str(cbRegionValues(i))];
            matlabbatch{1}.spm.util.imcalc.var = struct('name', {}, 'value', {});
            matlabbatch{1}.spm.util.imcalc.options.dmtx = 0;
            matlabbatch{1}.spm.util.imcalc.options.mask = 0;
            matlabbatch{1}.spm.util.imcalc.options.interp = 1;
            matlabbatch{1}.spm.util.imcalc.options.dtype = 4;
            
            spm_jobman('run',matlabbatch);
        end
    case 'PCM_cortical_reslice_ROI_byhand' %reslice hand-drawn ROIs to functional resolution
        
        sn = varargin{1};
        
        refImageDir = [glmDir, '/', subj_name{sn}]; %directories for functional reference image (beta 1)
        cortROIDir = [pcmDir, '/', subj_name{sn}]; %and for cortical ROIs
        
        rois = {'timing_premotorROI', 'integrated_parietalROI'};
        
        for r=1:length(rois) %loop through subcortical regions and reslice them to beta image resolution
            
            matlabbatch{1}.spm.spatial.realign.write.data = {[refImageDir, '/beta_0001.nii']; [cortROIDir, '/', subj_name{sn}, '_', rois{r}, '.nii']};
            matlabbatch{1}.spm.spatial.realign.write.roptions.which = [2 1];
            matlabbatch{1}.spm.spatial.realign.write.roptions.interp = 4;
            matlabbatch{1}.spm.spatial.realign.write.roptions.wrap = [0 0 0];
            matlabbatch{1}.spm.spatial.realign.write.roptions.mask = 1;
            matlabbatch{1}.spm.spatial.realign.write.roptions.prefix = 'r';
            
            spm_jobman('run',matlabbatch);
            disp([rois{r} ' resliced'])
        end
    case 'PCM_cortical_define_mva_area_byhand' %converts RoI from hand-drawn .nii to voxel coordinate .mat for PCM
        
        s=varargin{1};
        rois = {'timing_premotorROI', 'integrated_parietalROI'};
        
        % load respective subcortical .nii and extract x y z coordinates for voxels
        for r=1:length(rois)
            cd(fullfile(pcmDir, subj_name{s}));
            V=spm_vol(['r' subj_name{s} '_' rois{r} '.nii']);
            X=spm_read_vols(V);
            [i,j,k]=ind2sub(size(X),find(X~=0));
            vox=[i j k];
            
            LI{1} = sub2ind(V.dim,vox(:,1),vox(:,2),vox(:,3)); %convert x y z coordinates into linear index for voxels
            voxmin = min(vox,[],1); %min x y z coordinates for each voxel
            voxmax = max(vox,[],1); %max as above
            n = size(vox,1); %number of voxels
            
            save(sprintf('%s_decodeArea_%s.mat',subj_name{s},rois{r}), 'vox', 'LI', 'voxmin', 'voxmax', 'n')
            disp([rois{r} ' done'])
        end
    case 'PCM__cortical_fitModels_ROI_byhand' %fits PCM models to data from hand-drawn ROIs
        
        %Hand-generate cortical RoIs for each participant (?)
        %PMv, SPCa
        %Using MRIcron draw tool
        
        rois = {'timing_premotorROI', 'integrated_parietalROI'};
        
        %load 9 representational models
        cd(modelDir)
        files = dir('*.mat');
        for i=1:length(files)
            load(files(i).name)
            models.(D.modelName) = D;
        end
        clear('D')
        anaSubj = [3, 5, 6, 7, 9];
        
        %load subcortical data for analysis
        loopCounter = 1;
        for s=anaSubj
            %         for s=3
            
            cd(fullfile(glmDir, subj_name{s})); %load SPM data
            load SPM;
            nrruns=length(SPM.nscan);
            
            runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
            prep      =[0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0];
            prep=[repmat(prep,1,nrruns) runBSL];
            
            prod      =[1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0];
            prod=[repmat(prod,1,nrruns) runBSL];
            
            c=repmat(1:8,1,nrruns)'; % extract conditions (leave out errors!)
            run=[1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6]'; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
            
            [~,prepCol] = find(prep>0); prepCol = reshape(prepCol,4,[]);
            [~,prodCol] = find(prod>0); prodCol = reshape(prodCol,4,[]);
            col = [prepCol; prodCol]; col = reshape(col,1,[]);
            
            
            P={SPM.Vbeta(1:126).fname}';
            Pselect=[];
            for i=1:length(col)
                Pselect{i,1}= P{col(i)};
            end
            
            S = load(fullfile(pcmDir,subj_name{s},[subj_name{s} '_decodeArea_' rois{2} '.mat']));
            Vin = spm_vol(char(Pselect));
            
            %extract voxels in decoding area from beta files and pass to MVPA function
            linVox=unique(cat(2,S.LI{:})');
            [I,J,K]=ind2sub(Vin(1).dim,linVox);
            X = zeros(length(linVox),length(Vin));
            
            for i=1:length(Vin) %this gives us a voxelN x betaN matrix
                X(:,i)=spm_sample_vol(Vin(i),double(I),double(J),double(K),0);
            end
            
            [nanidx, ~] = find(isnan(X)); %remove nan values contained in beta image due to signal loss(?)
            nanidx = unique(nanidx);
            X(nanidx,:) = [];
            Y{:,loopCounter}=X';
            
            loopCounter = loopCounter+1;
        end%subj loop
        
        for i=1:length(Y)
            G_hat(:,:,i)=pcm_estGCrossval(Y{:,i},run,c);
        end;
        
        Gm = mean(G_hat,3); % Mean estimate
        
        orderPrepModel.G = pcm_estGCrossval(models.ordPrep.data,run,c); orderPrepModel.G(isnan(orderPrepModel.G)) = 0;
        timingPrepModel.G = pcm_estGCrossval(models.tempPrep.data,run,c); timingPrepModel.G(isnan(timingPrepModel.G)) = 0;
        integratedPrepModel.G = pcm_estGCrossval(models.intPrep.data,run,c); integratedPrepModel.G(isnan(integratedPrepModel.G)) = 0;
        
        orderProdModel.G = pcm_estGCrossval(models.ordProd.data,run,c); orderProdModel.G(isnan(orderProdModel.G)) = 0;
        timingProdModel.G = pcm_estGCrossval(models.tempProd.data,run,c); timingProdModel.G(isnan(timingProdModel.G)) = 0;
        integratedProdModel.G = pcm_estGCrossval(models.intProd.data,run,c); integratedProdModel.G(isnan(integratedProdModel.G)) = 0;
        
        orderSwitchModel.G = pcm_estGCrossval(models.ordSwitch.data,run,c); orderSwitchModel.G(isnan(orderSwitchModel.G)) = 0;
        timingSwitchModel.G = pcm_estGCrossval(models.tempSwitch.data,run,c); timingSwitchModel.G(isnan(timingSwitchModel.G)) = 0;
        integratedSwitchModel.G = pcm_estGCrossval(models.intSwitch.data,run,c); integratedSwitchModel.G(isnan(integratedSwitchModel.G)) = 0;
        
        figure
        subplot(3,7,[1, 8]);
        H = eye(8)-ones(8)/8;
        imagesc(H*Gm*H');
        title('Empirical Data')
        
        C= pcm_indicatorMatrix('allpairs',[1:8]');
        [COORD,l]=pcm_classicalMDS(Gm,'contrast',C);
        subplot(3,7,15);
        plot(COORD(:,1),COORD(:,2),'o');
        axis equal;
        
        % visualise models
        subplot(3,7,2);
        imagesc(orderPrepModel.G);
        title('Order Prep')
        
        subplot(3,7,9);
        imagesc(orderProdModel.G);
        title('Order Prod')
        
        subplot(3,7,16);
        imagesc(orderSwitchModel.G);
        title('Order Switch')
        
        subplot(3,7,3);
        imagesc(timingPrepModel.G);
        title('Timing Prep')
        
        subplot(3,7,10);
        imagesc(timingProdModel.G);
        title('Timing Prod')
        
        subplot(3,7,17);
        imagesc(timingSwitchModel.G);
        title('Timing Switch')
        
        subplot(3,7,4);
        imagesc(integratedPrepModel.G);
        title('Integrated Prep')
        
        subplot(3,7,11);
        imagesc(integratedProdModel.G);
        title('Integrated Prod')
        
        subplot(3,7,18);
        imagesc(integratedSwitchModel.G);
        title('Integrated Switch')
        
        % ----------------------------------------------------------------
        % Now build the models
        % Model 1: Null model for baseline: here we use a model which has all finger
        % Patterns be independent - i.e. all finger pairs are equally far away from
        % each other
        M{1}.type       = 'component';
        M{1}.numGparams = 1;
        M{1}.Gc         = ones(8);
        M{1}.name       = 'null';
        
        % Models 2-4: Order models, derived from simulations with
        % high order decoding during prep, prod, & switch respectively
        M{2}.type       = 'component';
        M{2}.numGparams = 1;
        M{2}.Gc         = orderPrepModel.G;
        M{2}.name       = 'orderPrep';
        
        M{3}.type       = 'component';
        M{3}.numGparams = 1;
        M{3}.Gc         = orderProdModel.G;
        M{3}.name       = 'orderProd';
        
        M{4}.type       = 'component';
        M{4}.numGparams = 1;
        M{4}.Gc         = orderSwitchModel.G;
        M{4}.name       = 'orderSwitch';
        
        % Models 5-7: Timing models, derived from simulations with
        % high timing decoding during prep, prod, & switch respectively
        M{5}.type       = 'component';
        M{5}.numGparams = 1;
        M{5}.Gc         = timingPrepModel.G;
        M{5}.name       = 'timingPrep';
        
        M{6}.type       = 'component';
        M{6}.numGparams = 1;
        M{6}.Gc         = timingProdModel.G;
        M{6}.name       = 'timingProd';
        
        M{7}.type       = 'component';
        M{7}.numGparams = 1;
        M{7}.Gc         = timingSwitchModel.G;
        M{7}.name       = 'timingSwitch';
        
        % Models 8-10: Integrated models, derived from simulations with
        % high integrated decoding
        M{8}.type       = 'component';
        M{8}.numGparams = 1;
        M{8}.Gc         = integratedPrepModel.G;
        M{8}.name       = 'integratedPrep';
        
        M{9}.type       = 'component';
        M{9}.numGparams = 1;
        M{9}.Gc         = integratedProdModel.G;
        M{9}.name       = 'integratedProd';
        
        M{10}.type       = 'component';
        M{10}.numGparams = 1;
        M{10}.Gc         = integratedSwitchModel.G;
        M{10}.name       = 'integratedSwitch';
        
        % Model 11: Additive mixture between order and timing models
        M{11}.type       = 'component';
        M{11}.numGparams = 2;
        M{11}.Gc(:,:,1)  = orderPrepModel.G;
        M{11}.Gc(:,:,2)  = orderProdModel.G;
        M{11}.name       = 'orderPrep + orderProd';
        
        % Model 12: Additive mixture between order and timing models
        M{12}.type       = 'component';
        M{12}.numGparams = 2;
        M{12}.Gc(:,:,1)  = timingPrepModel.G;
        M{12}.Gc(:,:,2)  = timingProdModel.G;
        M{12}.name       = 'timingPrep + timingProd';
        
        % Model 6: Free model as Noise ceiling
        M{13}.type       = 'freedirect';
        M{13}.numCond    = 8;
        M{13}.name       = 'noiseceiling';
        M{13}            = pcm_prepFreeModel(M{13});
        
        % Treat the run effect as random or fixed?
        % We are using a fixed run effect here, as we are not interested in the
        % activity relative the the baseline (rest) - so as in RSA, we simply
        % subtract out the mean patttern across all conditions.
        runEffect  = 'fixed';
        
        % Fit the models on the group level
        [Tgroup,theta] = pcm_fitModelGroup(Y,M,run,c,'runEffect',runEffect,'fitScale',1);
        
        % Fit the models through cross-subject crossvalidation
        [Tcross,thetaCr] = pcm_fitModelGroupCrossval(Y,M,run,c,'runEffect',runEffect,'groupFit',theta,'fitScale',1);
        
        % Provide a plot of the crossvalidated likelihoods
        subplot(3,7,[5 6 7 12 13 14 19 20 21]);
        T = pcm_plotModelLikelihood(Tcross,M,'upperceil',Tgroup.likelihood(:,length(M)));
        %         title('Preparation')
    case 'PCM_cortical_do_SearchLight' % Conduct the PCM in subcortical searchlights
        
        s=varargin{1};
        
        for r=1 %:length(subcortStructs);
            
            cd(fullfile(glmDir, subj_name{s}));
            load SPM;
            nrruns=length(SPM.nscan);
            
            
            runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
            prod      =[1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0];
            prod=[repmat(prod,1,nrruns) runBSL];
            
            c=repmat(1:4,1,nrruns); % extract conditions (leave out errors!)
            run=[1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6]; % extract run nr; or generate: run=kron([1:nrruns],ones(1,9)); %or just run=D.RN
            out = {fullfile(pcmDir, subj_name{s}, [subj_name{s}, '_' subcortStructs{r} 'PCMLikelihood.nii'])};
            
            
            % Generate column indices for Cross-validation, where
            % cell i contains column indices of the respective test and
            % train set
            for i=1:nrruns
                test{i}=find(run==i);  %fprintf('test:'); display(test{i}');
                train{i}=find(run~=i);  %fprintf('train:'); display(train{i}');
            end;
            
            [row,col] = find(prod>0);
            P={SPM.Vbeta(1:126).fname}';
            Pselect=[];
            for i=1:length(col)
                Pselect{i,1}= P{col(i)};
            end
            
            tstart = tic
            lmva_spm(fullfile(subcorticalSearchDir,subj_name{s},[subj_name{s} '_' subcortStructs{r} '_volsearch160.mat']),Pselect,out,@combinedclass,'params',{c,run,train,test});
            telapsed = toc(tstart)
        end
        
    case 'RSA_dataPrep' % RSA data prep from RSA toolbox
        
        %standard function to convert fMRI data to a format compatible with RSA toolbox
        userOptions = prepProdRSA_defineUserOptions(baseDir); %this function must be modified for each project
        betaCorrespondence = prepProdRSA_betaCorrespondence(); %likewise
        
        fullBrainVols = rsa.fmri.fMRIDataPreparation(betaCorrespondence, userOptions);
        binaryMasks_nS = rsa.fmri.fMRIMaskPreparation(userOptions);
        rsa.fmri.fMRIDataMasking(fullBrainVols, binaryMasks_nS, betaCorrespondence, userOptions); %very long
    case 'RSA_calculateRDMs' %generates RDMs
        cd([baseDir filesep 'imaging'])
        load(fullfile(baseDir, 'imaging', 'ImageData', 'prepProd_ImageData.mat'),        'fullBrainVols');
        load(fullfile(baseDir, 'imaging', 'ImageData', 'prepProd_Masks.mat'),            'binaryMasks_nS');
        load(fullfile(baseDir, 'imaging', 'ImageData', 'prepProd_responsePatterns.mat'), 'responsePatterns');
        
        userOptions = prepProdRSA_defineUserOptions(baseDir);
        betaCorrespondence = prepProdRSA_betaCorrespondence();
        
        RDMs  = rsa.constructRDMs(responsePatterns, betaCorrespondence, userOptions);
        sRDMs = rsa.rdm.averageRDMs_subjectSession(RDMs, 'session');
        RDMs  = rsa.rdm.averageRDMs_subjectSession(RDMs, 'session', 'subject');
        
        Models = rsa.constructModelRDMs(modelRDMs(), userOptions);
        %rsa.figureRDMs(RDMs, userOptions, struct('fileName', 'RoIRDMs', 'figureNumber', 1));
        %rsa.figureRDMs(Models, userOptions, struct('fileName', 'ModelRDMs', 'figureNumber', 2));
        
        %rsa.MDSConditions(RDMs, userOptions);
        %rsa.dendrogramConditions(RDMs, userOptions);
        
        rsa.pairwiseCorrelateRDMs({RDMs}, userOptions);
        
    case 'cerebellum_makeROIs' %uses region toolbox to define R struct to pass to searchlight definition
        
        s=varargin{1};
        suitCBRegions = suitCBRegions(2,:);%names from second row
        R=cell(length(suitCBRegions), 1);
        cd(fullfile(cerebellumDir, subj_name{s}))
        
        for i=1:length(suitCBRegions)%for each subcort region
            R{i} = region('roi_image', fullfile(cerebellumDir, 'atlasSUIT', [suitCBRegions{i} '.nii']), 1, suitCBRegions{i});
            R{i}.name = [subj_name{s} '_' suitCBRegions{i}]; %use toolbox to define, then add name
        end%for each subcort region
        
        %R = region_calcregions(R);%because we reslice, we don't need voxelspace option
        R = region_calcregions(R, 'voxelspace', fullfile(glmDir, subj_name{s}, 'beta_0001.nii'));
        for i=1:length(R)
            region_saveasimg(R{i}, fullfile(glmDir, subj_name{s}, 'beta_0001.nii'))
        end
        out = [roiCbDir '/' subj_name{s} '_cerebellum_roi'];
        save(strjoin(out,''), 'R'); %save as participant file which holds all regions
    
    case 'cerebellum searchlight within lobules' %below are functions to run CB RSA searchlights within lobules
    case 'cerebellum_reslice_rois' %uses SUIT to reslice SUIT atlas ROIs into native space
        
        sn = varargin{1};
        cd(fullfile(suitDir, subj_name{sn}))
        
        inFiles  = strcat(fullfile(suitDir, 'atlasSUIT'), '/', suitCBRegions(2,:), '.nii')';
        outFiles = strcat(fullfile(suitDir, subj_name{sn}), '/', subj_name{sn}, '_', suitCBRegions(2,:), '.nii')';
        
        job.Affine     = {fullfile(anatDir, subj_name{sn}, ['Affine_' subj_name{sn} '_anatomical_seg1.mat'])};
        job.flowfield  = {fullfile(anatDir, subj_name{sn}, ['u_a_' subj_name{sn} '_anatomical_seg1.nii'])};
        job.resample   = inFiles;
        job.ref        = {fullfile(anatDir, subj_name{sn}, [subj_name{sn} '_anatomical.nii'])};
        job.out        = outFiles;
        
        suit_reslice_dartel_inv_RY(job)
        
        
        %         refImageDir = [cerebellumDir, '/', subj_name{sn}]; %directories for functional reference image (beta 1)
        %         cerebellumImageDir = [cerebellumDir, '/atlasSUIT']; %and for cerebellar images
        %
        %         for r=1:length(suitCBRegions) %loop through cerebellar regions and reslice them to beta image resolution (2x2mm iso)
        %
        %             matlabbatch{1}.spm.spatial.realign.write.data = {[refImageDir, '/beta_0001.nii']; [cerebellumImageDir, '/', suitCBRegions{2,r}, '.nii']};
        %             matlabbatch{1}.spm.spatial.realign.write.roptions.which = [2 1];
        %             matlabbatch{1}.spm.spatial.realign.write.roptions.interp = 4;
        %             matlabbatch{1}.spm.spatial.realign.write.roptions.wrap = [0 0 0];
        %             matlabbatch{1}.spm.spatial.realign.write.roptions.mask = 1;
        %             matlabbatch{1}.spm.spatial.realign.write.roptions.prefix = 'r';
        %
        %             spm_jobman('run',matlabbatch);
        %             disp([suitCBRegions{2,r} ' resliced'])
        %         end
    case 'cerebellum_roi_to_func_res' %reslice cerebellar structures into functional resolution - for voxel selection in later searchlight
        
        sn = varargin{1}; %requires any participant input to identify functional resolution
        cd(fullfile(suitDir, subj_name{sn}))
        suitCBRegions = suitCBRegions(2,:);%names from second row
        
        refImageDir = [glmDir, '/', subj_name{sn}]; %directories for functional reference image (beta 1)
        suitAtlasDir = [suitDir, '/' subj_name{sn}]; %and for cerebellar roi images
        
        for r=1:length(suitCBRegions) %loop through cerebellar regions and reslice them to beta image resolution
            
            matlabbatch{1}.spm.spatial.realign.write.data = {[refImageDir, '/beta_0001.nii']; [suitAtlasDir, '/', subj_name{sn}, '_' suitCBRegions{r}, '.nii']};
            matlabbatch{1}.spm.spatial.realign.write.roptions.which = [2 1];
            matlabbatch{1}.spm.spatial.realign.write.roptions.interp = 4;
            matlabbatch{1}.spm.spatial.realign.write.roptions.wrap = [0 0 0];
            matlabbatch{1}.spm.spatial.realign.write.roptions.mask = 1;
            matlabbatch{1}.spm.spatial.realign.write.roptions.prefix = 'r';
            
            spm_jobman('run',matlabbatch);
            disp([suitCBRegions{r} ' resliced'])
            
            %%%Threshold likelihood of resliced image. 0.7 gives us a good
            %%%reflection of the original, adjust accordingly
            Vi = spm_vol(['r' subj_name{sn} '_' suitCBRegions{r} '.nii']);
            Vo = Vi;
            spm_imcalc(Vi, Vo, 'i1 > 0.7');
        end
    case 'cerebellum_makesearch'
        
        sn=varargin{1};
        cd(fullfile(suitDir, subj_name{sn}))
        suitCBRegions = suitCBRegions(2,:);%names from second row
        
        for i=1:length(suitCBRegions)
            R = spm_vol(['r' subj_name{sn} '_' suitCBRegions{i} '.nii']);
            R.data = spm_read_vols(R);
            R.mask = R.data;
            
            maskName  = fullfile(suitDir, subj_name{sn}, 'maskbrainSUIT.nii');
            mask      = spm_vol(maskName);
            mask.data = spm_read_vols(mask);
            mask.mask = mask.data;
            
            L = rsa.defineSearchlight_volume_RY(R, mask);
            
            save(['volsearch160_' suitCBRegions{i} '.mat'], 'L')
        end
    case 'cerebellum_runsearch'
        
        s=varargin{1}; blueBear=varargin{2};
        suitCBRegions = suitCBRegions(2,:);%names from second row
        nrruns = length(run); nCond = 8;
        
        for r=1:length(suitCBRegions)
            cd(fullfile(suitDir, subj_name{s}))
            
            %%% Searchlight file
            load(fullfile(suitDir,subj_name{s},['volsearch160_' suitCBRegions{r} '.mat']), 'L');
            
            %%% SPM file
            spmDir = fullfile(glmDir, subj_name{s});
            load(fullfile(spmDir, 'SPM'), 'SPM');
            
            %replace fnames for bluebear compatibility
            if blueBear == 1
                for i=1:length(SPM.xY.VY)
                    SPM.xY.VY(i).fname = strrep(SPM.xY.VY(i).fname,'\','/');
                    SPM.xY.VY(i).fname = strrep(SPM.xY.VY(i).fname,'Z:','/rds/projects/k/kornyshk-kornyshevalab');
                end
            else
            end
            
            %%% prepare condition and partition (run) vectors
            runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
            prep      =[0 0 1 0 0 0 2 0 0 0 3 0 0 0 4 0 0 0 0 0]; %prep
            prep=[repmat(prep,1,nrruns) runBSL];%1 x nBeta, 1 2 3 4 = prep sequences 1:4
            
            prod      =[5 0 0 0 6 0 0 0 7 0 0 0 8 0 0 0 0 0 0 0]; %prod
            prod=[repmat(prod,1,nrruns) runBSL];%1 x nBeta, 5 6 7 8 = prod sequences 1:4
            
            condVec = prep + prod; condVec = condVec'; % conditions, including no interest regressors as 0
            
            %%% Run searchlight function on whole CB
            rsa.runSearchlightLDC_RY(L, SPM, 'spmDir', spmDir, 'conditionVec', condVec, 'analysisName', ['overallCross_' suitCBRegions{r}])
        end
    case 'cerebellum_calc_dissimilarity_maps' %extract each condition (order prep, timing prep, etc) from overall searchlight .nii
        %each volume of the searchlight corresponds to a pairwise
        %dissimilarity measure between sequences. So here we average within
        %our conditions to give us dissimilarity measures for:
        %overall prep, overall prod, overall cross, order prep, order prod,
        %order cross, timing prep, timing prod, timing cross
        
        s=varargin{1}; suitCBRegions = suitCBRegions(2,:);%names from second row
        cd(fullfile(suitDir, subj_name{s}))
        
        %%% Identify and extract values for overall, order, and timing
        %%% within preparation, production, and cross-phase
        ordDiff        = [0 1 1 0 0 1 1 1 1 0 0 1 1 0 1 1 0 0 1 1 0 0 0 1 1 1 1 0]';   %pairwise contrast index (1s are where orders are different)
        timDiff        = [1 0 1 0 1 0 1 1 0 1 0 1 0 1 0 1 0 1 1 0 1 0 1 0 1 1 0 1]';   %^ index (1s are where timings are different)
        prepCols       = [1 1 1 0 0 0 0 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0]';   %^ index (1s are contrasts within preparation)
        prodCols       = [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1]';   %^ index (1s are contrasts within production)
        crossPhaseCols = [0 0 0 1 1 1 1 0 0 1 1 1 1 0 1 1 1 1 1 1 1 1 0 0 0 0 0 0]';   %^ index (1s are contrasts across phases)
        
        conds = {...
            'overall_prep', 'overall_prod', 'overall_cross', ...
            'order_prep',                                'order_prod',                                'order_cross', ...
            'timing_prep',                               'timing_prod',                               'timing_cross';...
            prepCols == 1,  prodCols == 1,  crossPhaseCols == 1, ...
            prepCols == 1 & ordDiff == 1 & timDiff == 0, prodCols == 1 & ordDiff == 1 & timDiff == 0, crossPhaseCols == 1 & ordDiff == 1 & timDiff == 0, ...
            prepCols == 1 & timDiff == 1 & ordDiff == 0, prodCols == 1 & timDiff == 1 & ordDiff == 0, crossPhaseCols == 1 & timDiff == 1 & ordDiff == 0 ...
            };
        
        for i=1:length(suitCBRegions)
            for j=1:length(conds)
                vol = spm_vol(['overall_' suitCBRegions{i} '_LDC.nii']);
                
                Vi = vol(conds{2,j}, :);
                Vo = Vi(1); Vo = rmfield(Vo, 'pinfo');
                Vo.fname = [subj_name{s} '_LDC_' conds{1,j} '_' suitCBRegions{i} '.nii'];
                Vo.n = [1 1];
                express = 'mean(X)';
                flags.dmtx = 1;
                
                spm_imcalc(Vi, Vo, express, flags)
            end
        end
    case 'cerebellum_sum_region_maps'
        
        s=varargin{1}; suitCBRegions = suitCBRegions(2,:);%names from second row
        cd(fullfile(suitDir, subj_name{s}))
        
        conds = {...
            'overall_prep', 'overall_prod', 'overall_cross', ...
            'order_prep',   'order_prod',   'order_cross', ...
            'timing_prep',  'timing_prod',  'timing_cross'...
            };
        %         for i=1:length(conds)
        %             for j=1:length(suitCBRegions)
        %                 volIn = spm_vol([subj_name{s} '_LDC_' conds{1,i} '_' suitCBRegions{j} '.nii']);
        %                 Vi(j) = volIn(end);
        %             end
        %             Vo = Vi(1); Vo = rmfield(Vo, 'pinfo');
        %             Vo.fname = [subj_name{s} '_LDC_' conds{i} '.nii'];
        %             Vo.n = [1 1];
        %             express = 'i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8';
        %             %flags.dmtx = 0;
        %             spm_imcalc(Vi, Vo, express, flags)
        
        for i=1:length(conds)
            for j=1:length(suitCBRegions)
                volIn = [subj_name{s} '_LDC_' conds{1,i} '_' suitCBRegions{j} '.nii'];
                Vi{j} = volIn;
            end
            express = 'i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8';
            
            matlabbatch{1}.spm.util.imcalc.input  = Vi;
            matlabbatch{1}.spm.util.imcalc.output = [subj_name{s} '_LDC_' conds{i} '.nii'];
            matlabbatch{1}.spm.util.imcalc.outdir = {suitScndDir};
            matlabbatch{1}.spm.util.imcalc.expression = express;
            matlabbatch{1}.spm.util.imcalc.options.dmtx = 0;
            matlabbatch{1}.spm.util.imcalc.options.mask = 0;
            matlabbatch{1}.spm.util.imcalc.options.interp = 1;
            matlabbatch{1}.spm.util.imcalc.options.dtype = 4;
            
            spm_jobman('run',matlabbatch);
            
            
        end
    case 'cerebellum_run_search_integrated' %runs the searchlight, but subtracts averaged order and timing patterns within runs
        %subtraction happens during distance function
        %(distanceLDC_cor4main_RY) within searchlight function
        
        s=varargin{1}; blueBear=varargin{2};
        nrruns = length(run);
        
        cd(fullfile(suitDir, subj_name{s}))
        
        %%% Searchlight file
        load(fullfile(suitDir,subj_name{s},'volsearch160SUIT.mat'), 'L');
        
        %%% SPM file
        spmDir = fullfile(glmDir, subj_name{s});
        load(fullfile(spmDir, 'SPM'), 'SPM');
        
        %replace fnames for bluebear compatibility
        if blueBear == 1
            for i=1:length(SPM.xY.VY)
                SPM.xY.VY(i).fname = strrep(SPM.xY.VY(i).fname,'\','/');
                SPM.xY.VY(i).fname = strrep(SPM.xY.VY(i).fname,'Z:','/rds/projects/k/kornyshk-kornyshevalab');
            end
        end
        
        %%% prepare condition and partition (run) vectors
        runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
        prep      =[0 0 1 0 0 0 2 0 0 0 3 0 0 0 4 0 0 0 0 0]; %prep
        prep=[repmat(prep,1,nrruns) runBSL];%1 x nBeta, 1 2 3 4 = prep sequences 1:4
        
        prod      =[5 0 0 0 6 0 0 0 7 0 0 0 8 0 0 0 0 0 0 0]; %prod
        prod=[repmat(prod,1,nrruns) runBSL];%1 x nBeta, 5 6 7 8 = prod sequences 1:4
        
        condVec = prep + prod; condVec = condVec'; % conditions, including no interest regressors as 0
        
        %%% Run searchlight function on whole CB
        rsa.runSearchlightLDC_cor4main_RY(L, SPM, 'spmDir', spmDir, 'conditionVec', condVec, ...
            'analysisName', [subj_name{s}, 'RSA_All_integrated'], 'outDir', fullfile(suitDir, subj_name{s}))
    case 'cerebellum_calc_dissimilarity_maps_integrated' %extract integrated prep, prod, cross from RSA_ALL_integrated_sLDC.nii
        %each volume of the searchlight corresponds to a pairwise
        %dissimilarity measure between sequences. So here we average within
        %our conditions to give us dissimilarity measures for:
        %Int prep, Int prod, int cross, order prep, order prod,
        %order cross, timing prep, timing prod, timing cross
        
        s=varargin{1};
        cd(fullfile(suitDir, subj_name{s}))
        
        %%% Identify and extract values for overall, order, and timing
        %%% within preparation, production, and cross-phase
        ordDiff        = [0 1 1 0 0 1 1 1 1 0 0 1 1 0 1 1 0 0 1 1 0 0 0 1 1 1 1 0]';   %pairwise contrast index (1s are where orders are different)
        timDiff        = [1 0 1 0 1 0 1 1 0 1 0 1 0 1 0 1 0 1 1 0 1 0 1 0 1 1 0 1]';   %^ index (1s are where timings are different)
        prepCols       = [1 1 1 0 0 0 0 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0]';   %^ index (1s are contrasts within preparation)
        prodCols       = [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1]';   %^ index (1s are contrasts within production)
        crossPhaseCols = [0 0 0 1 1 1 1 0 0 1 1 1 1 0 1 1 1 1 1 1 1 1 0 0 0 0 0 0]';   %^ index (1s are contrasts across phases)
        
        conds = {...
            'integrated_prep', 'integrated_prod', 'integrated_cross', ...
            'orderInt_prep',                                'orderInt_prod',                                'orderInt_cross', ...
            'timingInt_prep',                               'timingInt_prod',                               'timingInt_cross';...
            prepCols == 1,     prodCols == 1,     crossPhaseCols == 1, ...
            prepCols == 1 & ordDiff == 1 & timDiff == 0,    prodCols == 1 & ordDiff == 1 & timDiff == 0,    crossPhaseCols == 1 & ordDiff == 1 & timDiff == 0, ...
            prepCols == 1 & timDiff == 1 & ordDiff == 0,    prodCols == 1 & timDiff == 1 & ordDiff == 0,    crossPhaseCols == 1 & timDiff == 1 & ordDiff == 0 ...
            };
        
        for j=1:length(conds)
            vol = spm_vol([subj_name{s} 'RSA_ALL_integrated_sLDC.nii']);
            
            Vi = vol(conds{2,j}, :);
            Vo = Vi(1); Vo = rmfield(Vo, 'pinfo');
            Vo.fname = [subj_name{s} '_LDC_' conds{1,j} '.nii'];
            Vo.n = [1 1];
            express = 'mean(X)';
            flags.dmtx = 1;
            
            spm_imcalc(Vi, Vo, express, flags)
        end
        
    case 'subcortical_calculateRDMs_integrated'
        %subtracts averaged order and timing patterns within runs
        %subtraction happens during distance function
        %(distanceLDC_cor4main_RY)
        
        cd(roiSubDir)
        R = load('preWhitened_betas.mat');
        nrruns = length(run); nCond = 8;
        saveDir = fullfile(rsaDir, 'subcortical');
        
        %%% prepare condition and partition (run) vectors
        runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
        prep      =[0 0 1 0 0 0 2 0 0 0 3 0 0 0 4 0 0 0 0 0]; %prep
        prep=[repmat(prep,1,nrruns) runBSL];%1 x nBeta, 1 2 3 4 = prep sequences 1:4
        
        prod      =[5 0 0 0 6 0 0 0 7 0 0 0 8 0 0 0 0 0 0 0]; %prod
        prod=[repmat(prod,1,nrruns) runBSL];%1 x nBeta, 5 6 7 8 = prod sequences 1:4
        
        condVec = prep + prod; condVec = condVec'; % conditions, including no interest regressors as 0
        partVec = double(condVec > 0); %assign run number to beta
        for i=1:nCond %assign run numbers to conds, ignore no-interest betas
            partIdx = find(condVec == i);
            for j=1:length(run)
                partVec(partIdx(j)) = j;
            end
        end
        
        %%% loop through prewhitened data, calculate crossnobis dissimilarities
        %pre-allocate output variables
        R.d   = NaN(length(R.SN), nCond * (nCond - 1) / 2); %pairwise distance measures
        R.Sig = cell(length(R.SN), 1); %covariance matrix of the beta estimates across different imaging runs.
        R.G   = cell(length(R.SN), 1); %second moment matrix
        R.matrix = cell(length(R.SN), 1); % Pairwise contrast matrix
        
        for s = anaSubj
            load(fullfile(glmDir, subj_name{s}, 'SPM'), 'SPM') %load SPM design matrix for distance function
            for r = unique(R.region)'
                B = R.betaW{R.region == r & R.SN == s};
                
                [d, Sig] = rsa.distanceLDC_cor4main_RY(B, partVec, condVec, SPM.xX.X); %integrated function
                [G,~]    = pcm_estGCrossval(B,partVec,condVec, 'X', SPM.xX.X);
                matrix   = indicatorMatrix('allpairs',1:nCond); % Pairwise contrast matrix
                
                R.d     (R.region == r & R.SN == s, :) = d;
                R.Sig   {R.region == r & R.SN == s}    = Sig;
                R.G     {R.region == r & R.SN == s}    = G;
                R.matrix{R.region == r & R.SN == s}    = matrix;
            end
        end
        
        %%% Identify and extract values for overall, order, and timing
        %%% within preparation, production, and cross-phase
        orderDiff      = [0 1 1 0 0 1 1 1 1 0 0 1 1 0 1 1 0 0 1 1 0 0 0 1 1 1 1 0];   %pairwise contrast index (1s are where orders are different)
        timingDiff     = [1 0 1 0 1 0 1 1 0 1 0 1 0 1 0 1 0 1 1 0 1 0 1 0 1 1 0 1];   %^ index (1s are where timings are different)
        prepCols       = [1 1 1 0 0 0 0 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0];   %^ index (1s are contrasts within preparation)
        prodCols       = [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1];   %^ index (1s are contrasts within production)
        crossPhaseCols = [0 0 0 1 1 1 1 0 0 1 1 1 1 0 1 1 1 1 1 1 1 1 0 0 0 0 0 0];   %^ index (1s are contrasts across phases)
        
        for i=1:length(R.d)
            
            R.dOrderPrepInt(i,:)  = R.d(i, orderDiff == 1 & timingDiff == 0 & prepCols == 1);
            R.dOrderProdInt(i,:)  = R.d(i, orderDiff == 1 & timingDiff == 0 & prodCols == 1);
            R.dOrderCrossInt(i,:) = R.d(i, orderDiff == 1 & timingDiff == 0 & crossPhaseCols == 1);
            R.dOrderAllInt(i,:)   = R.d(i, orderDiff == 1 & timingDiff == 0);
            
            R.dTimingPrepInt(i,:)  = R.d(i, timingDiff == 1 & orderDiff == 0 & prepCols == 1);
            R.dTimingProdInt(i,:)  = R.d(i, timingDiff == 1 & orderDiff == 0 & prodCols == 1);
            R.dTimingCrossInt(i,:) = R.d(i, timingDiff == 1 & orderDiff == 0 & crossPhaseCols == 1);
            R.dTimingAllInt(i,:)   = R.d(i, timingDiff == 1 & orderDiff == 0);
            
            R.dIntegratedPrep(i,:)  = R.d(i, prepCols == 1);
            R.dIntegratedProd(i,:)  = R.d(i, prodCols == 1);
            R.dIntegratedCross(i,:) = R.d(i, crossPhaseCols == 1);
        end
        
        if ~isfolder(saveDir)
            mkdir(saveDir)
        end
        
        save(fullfile(saveDir, 'subRoiDistances_integrated.mat'), 'R')
    case 'subcortical_plotRDMs'
        subcortStructs = subcortStructs(2,:);%names from second row
        subcortStructs = strrep(subcortStructs, '_', ' '); %replace _ with space
        concatFile = fullfile(rsaDir, 'subcortical', 'subRoiDistancesAll.mat'); %file with all region distances
        
        if ~exist(concatFile, 'file')
            load(fullfile(rsaDir, 'subcortical', 'subRoiDistances.mat'), 'R');
            Rovr = R;
            load(fullfile(rsaDir, 'subcortical', 'subRoiDistances_integrated.mat'), 'R');
            Rint = R;
            
            conds = {...
                'dOverallPrep',    'dOverallProd',    'dOverallCross', ...%variable name
                'dOrderPrep',      'dOrderProd',      'dOrderCross', ...
                'dTimingPrep',     'dTimingProd',     'dTimingCross';...
                1,                 1,                 1, ...%overall/order/timing - cond
                2,                 2,                 2, ...
                3,                 3,                 3; ...
                1,                 2,                 3, ...%prep/prod/cross - phase
                1,                 2,                 3, ...
                1,                 2,                 3, ...
                };
            condsInt = {...
                'dIntegratedPrep', 'dIntegratedProd', 'dIntegratedCross';...
                4,                 4,                 4; ...%integrated - cond
                1,                 2,                 3, ...%prep/prod/cross - phase
                };
            nConds = length(conds);
            nCondsInt = length(condsInt);
            
            A = [];
            
            for i=1:nConds%for factorial conds
                Atemp.SN     = Rovr.SN;
                Atemp.region = Rovr.region;
                Atemp.dist   = mean(Rovr.(conds{1, i}), 2);%mean of relevant pairwise distances
                Atemp.cond   = ones(length(Atemp.dist), 1) * conds{2, i};
                Atemp.phase  = ones(length(Atemp.dist), 1) * conds{3, i};
                
                A = addstruct(A, Atemp);
                clear Atemp
            end%for factorial conds
            for i=1:nCondsInt%for int conds
                Atemp.SN     = Rint.SN;
                Atemp.region = Rint.region;
                Atemp.dist   = mean(Rint.(condsInt{1, i}), 2);%mean of relevant pairwise distances
                Atemp.cond   = ones(length(Atemp.dist), 1) * condsInt{2, i};
                Atemp.phase  = ones(length(Atemp.dist), 1) * condsInt{3, i};
                
                A = addstruct(A, Atemp);
                clear Atemp
            end%for int conds
            
            save(fullfile(rsaDir, 'subcortical', 'subRoiDistancesAll.mat'), 'A');
        else
            load(concatFile, 'A')%if it exists, load it
        end
        
        figure %%% General overview (zoom to regions of interest)
        T = tapply(A,{'SN', 'region', 'cond', 'phase'},{'dist', 'mean', 'name', 'dist'});
        colour={[0 0 0], [0 0.4470 0.7410], [0.6350 0.0780 0.1840], [0.4660 0.6740 0.1880]};
        regions = repmat({'l thal', 'l caud', 'l put', 'l pal', 'l hip', 'r thal', 'r caud', 'r put', 'r pal', 'r hip'}, 1, 12);
        barplot([T.phase, T.cond, T.region], T.dist, 'split', T.cond, 'facecolor', colour)
        ylim([-0.0017 0.022])
        set(gca,'xticklabel',regions)
        ylabel('Crossnobis dissimilarity')
        title('Overview')
        %-------------------------------------------------------------------------------%
        
        for i=1:length(subcortStructs)
            figure %%% Region plots for prep/prod order/timing/integrated
            T = tapply(A,{'SN', 'cond', 'phase'},{'dist', 'mean', 'name', 'dist'}, 'subset', A.region == i & A.cond > 1 & A.phase < 3);
            colour={[0 0.4470 0.7410], [0.6350 0.0780 0.1840], [0.4660 0.6740 0.1880]};
            lineplot([T.phase], T.dist, 'split', T.cond, ...
                'markertype', 'o', 'markercolor', colour, 'markerfill', colour, 'markersize', 5, ...
                'linecolor', colour, 'linewidth', 3, 'errorwidth', 2, 'errorcolor', colour)
            ylim([-0.0018 0.0055])
            drawline(0, 'dir', 'horz', 'linestyle', '- -')
            ylabel('Crossnobis dissimilarity')
            set(gca,'xticklabel',{'Prep', 'Prod'})
            title(subcortStructs{i})
        end
        %-------------------------------------------------------------------------------%
        
        figure %%% Investigate cross-phase distances
        T = tapply(A,{'SN', 'region', 'cond', 'phase'},{'dist', 'mean', 'name', 'dist'}, 'subset', A.cond == 1 & A.phase == 3);
        %colour={[0 0.4470 0.7410], [0.6350 0.0780 0.1840], [0.4660 0.6740 0.1880]};
        regions = repmat({'l thal', 'l caud', 'l put', 'l pal', 'l hip', 'r thal', 'r caud', 'r put', 'r pal', 'r hip'}, 1, 12);
        barplot([T.phase, T.cond, T.region], T.dist, 'split', T.cond) %'facecolor', colour)
        ylim([0 0.022])
        set(gca,'xticklabel',regions)
        ylabel('Crossnobis dissimilarity')
        title('Cross-phase')
        
    case 'cortical_run_search_integrated' %runs the distance searchlight, but subtracts averaged order and timing patterns within runs
        %subtraction happens during distance function
        %(distanceLDC_cor4main_RY) within searchlight function
        
        s=varargin{1}; blueBear=varargin{2};
        nrruns = length(run);
        
        cd(fullfile(rsaDir, 'cortical', subj_name{s}))
        
        %%% Searchlight file
        load(fullfile(glmDir,subj_name{s},'volsearch160RSA.mat'), 'L');
        
        %%% SPM file
        spmDir = fullfile(glmDir, subj_name{s});
        load(fullfile(spmDir, 'SPM'), 'SPM');
        
        %replace fnames for bluebear compatibility
        if blueBear == 1
            for i=1:length(SPM.xY.VY)
                SPM.xY.VY(i).fname = strrep(SPM.xY.VY(i).fname,'\','/');
                SPM.xY.VY(i).fname = strrep(SPM.xY.VY(i).fname,'Z:','/rds/projects/k/kornyshk-kornyshevalab');
            end
        end
        
        %%% prepare condition and partition (run) vectors
        runBSL=[0 0 0 0 0 0]; %rest baseline to attatch at the end of the vectors
        prep      =[0 0 1 0 0 0 2 0 0 0 3 0 0 0 4 0 0 0 0 0]; %prep
        prep=[repmat(prep,1,nrruns) runBSL];%1 x nBeta, 1 2 3 4 = prep sequences 1:4
        
        prod      =[5 0 0 0 6 0 0 0 7 0 0 0 8 0 0 0 0 0 0 0]; %prod
        prod=[repmat(prod,1,nrruns) runBSL];%1 x nBeta, 5 6 7 8 = prod sequences 1:4
        
        condVec = prep + prod; condVec = condVec'; % conditions, including no interest regressors as 0
        
        %%% Run searchlight function on whole CB
        rsa.runSearchlightLDC_cor4main_RY(L, SPM, 'spmDir', spmDir, 'conditionVec', condVec, ...
            'analysisName', [subj_name{s}, 'RSA_All_integrated'], 'outDir', fullfile(rsaDir, 'cortical', subj_name{s}))
    case 'cortical_calc_dissimilarity_maps_integrated' %extract integrated prep, prod, cross from RSA_ALL_integrated_sLDC.nii
        %each volume of the searchlight corresponds to a pairwise
        %dissimilarity measure between sequences. So here we average within
        %our conditions to give us dissimilarity measures for:
        %Int prep, Int prod, int cross, order prep, order prod,
        %order cross, timing prep, timing prod, timing cross
        
        s=varargin{1};
        cd(fullfile(rsaCorticalDir, subj_name{s}))
        
        %%% Identify and extract values for overall, order, and timing
        %%% within preparation, production, and cross-phase
        ordDiff        = [0 1 1 0 0 1 1 1 1 0 0 1 1 0 1 1 0 0 1 1 0 0 0 1 1 1 1 0]';   %pairwise contrast index (1s are where orders are different)
        timDiff        = [1 0 1 0 1 0 1 1 0 1 0 1 0 1 0 1 0 1 1 0 1 0 1 0 1 1 0 1]';   %^ index (1s are where timings are different)
        prepCols       = [1 1 1 0 0 0 0 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0]';   %^ index (1s are contrasts within preparation)
        prodCols       = [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1]';   %^ index (1s are contrasts within production)
        crossPhaseCols = [0 0 0 1 1 1 1 0 0 1 1 1 1 0 1 1 1 1 1 1 1 1 0 0 0 0 0 0]';   %^ index (1s are contrasts across phases)
        
        conds = {...
            'integrated_prep', 'integrated_prod', 'integrated_cross', ...
            'orderInt_prep',                                'orderInt_prod',                                'orderInt_cross', ...
            'timingInt_prep',                               'timingInt_prod',                               'timingInt_cross';...
            prepCols == 1,     prodCols == 1,     crossPhaseCols == 1, ...
            prepCols == 1 & ordDiff == 1 & timDiff == 0,    prodCols == 1 & ordDiff == 1 & timDiff == 0,    crossPhaseCols == 1 & ordDiff == 1 & timDiff == 0, ...
            prepCols == 1 & timDiff == 1 & ordDiff == 0,    prodCols == 1 & timDiff == 1 & ordDiff == 0,    crossPhaseCols == 1 & timDiff == 1 & ordDiff == 0 ...
            };
        
        for j=1:length(conds)
            vol = spm_vol([subj_name{s} 'RSA_ALL_integrated_sLDC.nii']);
            
            Vi = vol(conds{2,j}, :);
            Vo = Vi(1); Vo = rmfield(Vo, 'pinfo');
            Vo.fname = [subj_name{s} '_LDC_' conds{1,j} '.nii'];
            Vo.n = [1 1];
            express = 'mean(X)';
            flags.dmtx = 1;
            
            spm_imcalc(Vi, Vo, express, flags)
        end
        
    case 'simulations_RSA_LDA' %includes factorial distance measures (that we ended up dropping)
        
        %%%Prepare variables
        prepProd = 1;
        vord     = [0.3 0.1];
        vtemp    = [0.4 0.7];
        vinter   = [0.6 0.8];
        vnoise   = 0.5;
        nIter    = 500;%acts as subj number
        
        vararginoptions(varargin,{'prepProd','vord','vtemp','vinter','vnoise','nIter','sn'});
        A=[]; %data struct
        B=[]; %output struct - stores distances, LDA, G matrix
        D=[]; %raw data store
        
        %%%Prepare condition and partition (run) vectors
        nrruns = 6; nCond = 8;
        runC      = repmat(1:nrruns,nCond,1); %labelling runs 1:6 (imaging runs)
        runC      = reshape(runC,1,[])';
        condC     = repmat((1:nCond)', nrruns, 1); %labelling conditions 1:4 (sequences)
        condCOrd  = repmat([1 1 2 2 3 3 4 4]', 6, 1);
        condCTemp = repmat([1 2 1 2 3 4 3 4]', 6, 1);
        
        %%%Generate data
        for i=1:nIter %for 'subject' n
            %make the data based on input specifications
            Y=prepProdSimu_makedataPP('prepProd',prepProd,'vord',vord,'vtemp',vtemp,'vinter',vinter,'vnoise',vnoise);
            
            A.data{i} = Y;
            
            %%%Generate distances vector
            [A.d{i},     A.Sig{i}]     = rsa.distanceLDC(A.data{i}, runC, condC);
            [A.dOrd{i},  A.SigOrd{i}]  = rsa.distanceLDC_oneOut_RY(A.data{i}, runC, condC, condCOrd);
            [A.dTemp{i}, A.SigTemp{i}] = rsa.distanceLDC_oneOut_RY(A.data{i}, runC, condC, condCTemp);
            [A.dInt{i},  A.SigInt{i}]  = rsa.distanceLDC_cor4main_RY(A.data{i}, runC, condC);
            
            %%%Run linear decoding
            prepData = [A.data{i}(1:4,:); A.data{i}(9:12,:);  A.data{i}(17:20,:); A.data{i}(25:28,:); A.data{i}(33:36,:); A.data{i}(41:44,:)];
            prodData = [A.data{i}(5:8,:); A.data{i}(13:16,:); A.data{i}(21:24,:); A.data{i}(29:32,:); A.data{i}(37:40,:); A.data{i}(45:48,:)];
            
            %               accuracy columns
            %1: overall,        2: order,          3: timing,         4:integrated(Z)    5: integrated(acc) for debugging
            [prepAccuracy(i,1), prepAccuracy(i,2), prepAccuracy(i,3), prepAccuracy(i,4), prepAccuracy(i,5)]=prepProdSimu_classify(prepData);
            [prodAccuracy(i,1), prodAccuracy(i,2), prodAccuracy(i,3), prodAccuracy(i,4), prodAccuracy(i,5)]=prepProdSimu_classify(prodData);
        end%for subject n
        
        % Identify and extract values for overall, order, and timing
        % within preparation, production, and cross-phase
        diffVectorOvr  = [... %index (1s are where condition is different)
            1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1; ...%overall
            ];
        %0 1 1 0 0 1 1 1 1 0 0 1 1 0 1 1 0 0 1 1 0 0 0 1 1 1 1 0; ...%order
        %1 0 1 0 1 0 1 1 0 1 0 1 0 1 0 1 0 1 1 0 1 0 1 0 1 1 0 1; ...%timing
        %0 0 1 0 0 0 1 1 0 0 0 1 0 0 0 1 0 0 1 0 0 0 0 0 1 1 0 0; ...%integrated
        
        %diffVector  = [...
        %diffVector(1,:); ...%overall stays the same
        %diffVector(2,:) == 1 & diffVector(3,:) == 0; ...%ONLY sequences with diff order & SAME timing
        %diffVector(3,:) == 1 & diffVector(2,:) == 0; ...%vice versa as above
        %diffVector(4,:); ...%integrated stays the same
        %];
        %diffVectorInt = [...
        %1 1 0 0 1 1 0 0 1 1 0 0 1 1 1 0 0 1 0 1 1 0 1 1 0 0 1 1; ...%integrated
        %];
        phaseVector = [...%index (1s are where phase is different)
            1 1 1 0 0 0 0 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0; ...%prep
            0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1; ...%prod
            0 0 0 1 1 1 1 0 0 1 1 1 1 0 1 1 1 1 1 1 1 1 0 0 0 0 0 0  ...%cross
            ];
        phaseVectorOneOut = [...
            1 0 0 0 0 0; ...%prep
            0 0 0 0 0 1; ...%prod
            0 1 1 1 1 0; ...%cross
            ];
        
        %%%Loop over subjs, conditions, and phases, and store distances as
        %%%struct to plot later
        loopCounter = 1;
        
        %%% Overall
        for s=1:nIter%for subj
            for i=1:size(phaseVector, 1)%for phase
                for j=1:size(diffVectorOvr, 1)%for conds
                    B.dist(loopCounter,1)  = mean(A.d{s}(phaseVector(i,:) & diffVectorOvr(j,:)));
                    B.phase(loopCounter,1) = i;
                    B.cond(loopCounter,1)  = j;
                    B.sn(loopCounter,1)    = s;
                    loopCounter = loopCounter + 1;
                end%for conds
            end%for phase
        end%for subj
        
        %%% Order and timing
        for s=1:nIter%for subj
            for i=1:size(phaseVectorOneOut, 1)%for phase
                B.dist(loopCounter,1)  = mean(A.dOrd{s}(phaseVectorOneOut(i,:) == 1));
                B.phase(loopCounter,1) = i;
                B.cond(loopCounter,1)  = 2;
                B.sn(loopCounter,1)    = s;
                loopCounter = loopCounter + 1;
                B.dist(loopCounter,1)  = mean(A.dTemp{s}(phaseVectorOneOut(i,:) == 1));
                B.phase(loopCounter,1) = i;
                B.cond(loopCounter,1)  = 3;
                B.sn(loopCounter,1)    = s;
                loopCounter = loopCounter + 1;
            end%for phase
        end%for subj
        
        %%% Integrated
        for s=1:nIter%for subj
            for i=1:size(phaseVector, 1)%for phase
                B.dist(loopCounter,1)  = mean(A.dInt{s}(phaseVector(i,:) & diffVectorOvr(1,:)));
                B.phase(loopCounter,1) = i;
                B.cond(loopCounter,1)  = 4;
                B.sn(loopCounter,1)    = s;
                loopCounter = loopCounter + 1;
            end%for phase
        end%for subj
        
        loopCounter = 1;
        for s=1:nIter%for subj
            for i=1:size(prepAccuracy, 2)
                C.acc(loopCounter,1)   = prepAccuracy(s, i);
                C.phase(loopCounter,1) = 1;
                C.cond(loopCounter,1)  = i;
                C.sn(loopCounter,1)    = s;
                loopCounter = loopCounter + 1;
            end
        end%for subj
        
        for s=1:nIter%for subj
            for i=1:size(prodAccuracy, 2)
                C.acc(loopCounter,1)   = prodAccuracy(s, i);
                C.phase(loopCounter,1) = 2;
                C.cond(loopCounter,1)  = i;
                C.sn(loopCounter,1)    = s;
                loopCounter = loopCounter + 1;
            end
        end%for subj
        
        
        
        figure %%% General overview (zoom to regions of interest)
        T = tapply(B,{'sn', 'cond', 'phase'},{'dist', 'mean', 'name', 'dist'}, 'subset', B.phase < 3);
        colour={[0 0 0], [0 0.4470 0.7410], [0.6350 0.0780 0.1840], [0.4660 0.6740 0.1880]};
        barplot([T.phase, T.cond], T.dist, 'split', T.cond, 'facecolor', colour)
        ylabel('Crossnobis dissimilarity')
        title(['prepProd =', num2str(prepProd), '  iter=', num2str(nIter), '  ORD=',num2str(vord), '  TEMP=',num2str(vtemp), '  INTER=',num2str(vinter), '  NOISE=',num2str(vnoise)]);
        %-------------------------------------------------------------------------------%
        
        figure %%% General overview (zoom to regions of interest)
        T = tapply(C,{'sn', 'cond', 'phase'},{'acc', 'mean', 'name', 'acc'});
        colour={[0 0 0], [0 0.4470 0.7410], [0.6350 0.0780 0.1840], [0.4660 0.6740 0.1880]};
        barplot([T.phase, T.cond], T.acc, 'split', T.cond, 'facecolor', colour)
        ylabel('Decoding accuracy (Z)')
        title(['prepProd =', num2str(prepProd), '  iter=', num2str(nIter), '  ORD=',num2str(vord), '  TEMP=',num2str(vtemp), '  INTER=',num2str(vinter), '  NOISE=',num2str(vnoise)]);
        %-------------------------------------------------------------------------------%
        
        labels = {'O1T1p', 'O1T2p', 'O2T1p', 'O2T2p', 'O1T1P', 'O1T2P', 'O2T1P', 'O2T2P'};%p=prep, P=prod
        
        %%%Multi-dimensional scaling - RDM
        for s=1:length(A.data)%for iter
            d_hat(:,:,s)= squareform(A.d{s}); %calc representational dissimilarity matrix
        end%forIter
        dm = mean(d_hat,3); % Mean estimate
        
        figure
        %subplot(1,2,1);
        H = eye(8)-ones(8)/8;
        imagesc(H*dm*H');
        title(['prepProd =', num2str(prepProd), '  iter=', num2str(nIter), '  ORD=',num2str(vord), '  TEMP=',num2str(vtemp), '  INTER=',num2str(vinter), '  NOISE=',num2str(vnoise)]);
        xticks(1:8)
        xticklabels(labels);%p=prep, P=prod
        yticks(1:8)
        yticklabels(labels)
        
        % %%% Multi-dimensional scaling
        try
            RDMs.RDM   = dm;
            RDMs.name  = 'simulation';
            RDMs.color = [0 0 1];
            
            userOptions = prepProdSimuPP_defineUserOptions(baseDir);
            
            rsa.MDSConditions(RDMs, userOptions);
        catch
            disp('MDS Failed.')
        end
        %----------------------------------------------------------------------------------------------%
        
        %%%Multi-dimensional scaling - RDM
        for s=1:length(A.data)%for iter
            d_hatInt(:,:,s)= squareform(A.dInt{s}); %calc representational dissimilarity matrix
        end%forIter
        dmInt = mean(d_hatInt,3); % Mean estimate
        
        figure
        %subplot(1,2,1);
        H = eye(8)-ones(8)/8;
        imagesc(H*dmInt*H');
        title('Corrected for main (Integrated)');
        xticks(1:8)
        xticklabels(labels);%p=prep, P=prod
        yticks(1:8)
        yticklabels(labels)
        
        % %%% Multi-dimensional scaling
        try
            RDMsInt.RDM   = dmInt;
            RDMsInt.name  = 'simulation_integrated';
            RDMsInt.color = [0 0 1];
            
            userOptions = prepProdSimuPP_defineUserOptions;
            
            rsa.MDSConditions(RDMsInt, userOptions);
        catch
            disp('MDS Failed.')
        end
        
        T = tapply(C,{'sn', 'cond', 'phase'},{'acc', 'mean', 'name', 'acc'}, 'subset', C.phase == 1);
        barplot(T.cond,T.acc,'split',T.cond,'style_bold','leg',{'ovr', 'ord', 'temp' ,'inter'},'leglocation','north');
        title(['prepProd =', num2str(prepProd), '  iter=', num2str(nIter), '  ORD=',num2str(vord), '  TEMP=',num2str(vtemp), '  INTER=',num2str(vinter), '  NOISE=',num2str(vnoise)]);
        ylabel('acc');
        xlabel('factor');
        
        
end%switch
end%function prepProd2_obsolete

function varargout = runPCM(Yprewh, conditionVec, partitionVec, MF, varargin) % run PCM on prewhitened beta
runEffect   = 'fixed'; % run effect
verbose     = 1;
fitAlgorithm= 'NR';
numIter = 1e3;
pcm_vararginoptions(varargin,{'runEffect', 'verbose','fitAlgorithm', 'prior','numIter'});

% append noise ceiling model
MF{end+1}.type = 'freedirect';
MF{end}.numGparams = 0;
MF{end}.theta0 = [];
MF{end}.name = 'noise_ceiling';

% Run group-fit
[T, theta] = pcm_fitModelGroup(Yprewh, MF, partitionVec, conditionVec,...
    'runEffect', runEffect, ...
    'fitAlgorithm', 'NR', ...
    'verbose', verbose, 'MaxIteration', numIter);

% Do the crossvalidated group-fit
[Tcv, theta_cv] = pcm_fitModelGroupCrossval(Yprewh, MF, partitionVec, conditionVec,...
    'runEffect', runEffect, ...
    'fitAlgorithm', fitAlgorithm, ...
    'groupFit', theta, 'MaxIteration', numIter);

varargout = {T, Tcv, theta_cv};
end%runPCM

function varargout = runPCMSearchlight(Yprewh, conditionVec, partitionVec, MF, CompIdx, varargin) % run PCM on prewhitened beta
runEffect   = 'fixed'; % run effect
verbose     = 1;
fitAlgorithm= 'NR';
numIter = 1e3;
pcm_vararginoptions(varargin,{'runEffect', 'verbose','fitAlgorithm', 'prior','numIter'});

% append noise ceiling model
MF{end+1}.type = 'freedirect';
MF{end}.numGparams = 0;
MF{end}.theta0 = [];
MF{end}.name = 'noise_ceiling';

% Run group-fit
[~, theta] = pcm_fitModelGroup(Yprewh, MF, partitionVec, conditionVec,...
    'runEffect', runEffect, ...
    'fitAlgorithm', 'NR', ...
    'verbose', verbose, 'MaxIteration', numIter);

% Do the crossvalidated group-fit
[Tcv, ~] = pcm_fitModelGroupCrossval(Yprewh, MF, partitionVec, conditionVec,...
    'runEffect', runEffect, ...
    'fitAlgorithm', fitAlgorithm, ...
    'groupFit', theta, 'MaxIteration', numIter);

% calculate normal logBF
logBF = bsxfun(@minus, Tcv.likelihood, Tcv.likelihood(:,1));
noiseceiling = logBF(:,end);
logBF = logBF(:,1:end-1);

% calculate component logBF
[PP, logBFc] = pcm_componentPosterior(logBF, CompIdx);

% get PXP (spm_BMS) for logBFc
for c=1:3
    lme = [logBFc(:,c), zeros(size(logBFc(:,2)))];
    [~,~,~,pxp_] = spm_BMS (lme);
    pxp(:,c) = repmat(pxp_(1), size(lme,1),1);
end

% get PXP for noise-ceiling logBF (vs null)
lme = [noiseceiling, zeros(size(noiseceiling))];
[~,~,~,pxp_] = spm_BMS (lme);
pxp_ceiling(:,1) = repmat(pxp_(1), size(lme,1),1);

% concatenate results
p.logBF = logBF;
p.noiseceiling = noiseceiling;
p.pxp_ceiling = pxp_ceiling;
p.logBFc = logBFc;
p.pxp = pxp;
p.phase = repmat(2,length(pxp),1);
%             p.sn = repmat(s, length(pxp),1);
%             p.hemis = repmat(h, length(pxp),1);
%             p.patch = repmat(p, length(pxp),1);
%             p.nodeID = repmat(D.nodeID(1), length(pxp),1);

varargout = {mean(p.noiseceiling)};
end%runPCM